class freeFOClib.Machines.Components.SpacePhasorM "Physical transformation: multi phase <-> space phasors"
  parameter Integer m(min = 1) = 3 "Number of phases";
  parameter Real turnsRatio = 1.0 "Turns ratio";
  Real v[1](quantity = "ElectricPotential", unit = "V") "Instantaneous phase voltages";
  Real v[2](quantity = "ElectricPotential", unit = "V") "Instantaneous phase voltages";
  Real v[3](quantity = "ElectricPotential", unit = "V") "Instantaneous phase voltages";
  Real i[1](quantity = "ElectricCurrent", unit = "A") "Instantaneous phase currents";
  Real i[2](quantity = "ElectricCurrent", unit = "A") "Instantaneous phase currents";
  Real i[3](quantity = "ElectricCurrent", unit = "A") "Instantaneous phase currents";
  protected parameter Real TransformationMatrix[1,1] = 2.0 / /*Real*/(m);
  protected parameter Real TransformationMatrix[1,2] = cos(6.283185307179586 / /*Real*/(m)) * 2.0 / /*Real*/(m);
  protected parameter Real TransformationMatrix[1,3] = cos(12.56637061435917 / /*Real*/(m)) * 2.0 / /*Real*/(m);
  protected parameter Real TransformationMatrix[2,1] = 0.0;
  protected parameter Real TransformationMatrix[2,2] = sin(6.283185307179586 / /*Real*/(m)) * 2.0 / /*Real*/(m);
  protected parameter Real TransformationMatrix[2,3] = sin(12.56637061435917 / /*Real*/(m)) * 2.0 / /*Real*/(m);
  protected parameter Real InverseTransformation[1,1] = 1.0;
  protected parameter Real InverseTransformation[1,2] = -0.0;
  protected parameter Real InverseTransformation[2,1] = cos(-6.283185307179586 / /*Real*/(m));
  protected parameter Real InverseTransformation[2,2] = -sin(-6.283185307179586 / /*Real*/(m));
  protected parameter Real InverseTransformation[3,1] = cos(-12.56637061435917 / /*Real*/(m));
  protected parameter Real InverseTransformation[3,2] = -sin(-12.56637061435917 / /*Real*/(m));
  parameter Integer plug_p.m(min = 1) = m "Number of phases";
  Real plug_p.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real plug_p.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real plug_p.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real plug_p.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real plug_p.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real plug_p.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  parameter Integer plug_n.m(min = 1) = m "Number of phases";
  Real plug_n.pin[1].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real plug_n.pin[1].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real plug_n.pin[2].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real plug_n.pin[2].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real plug_n.pin[3].v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real plug_n.pin[3].i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real zero.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real zero.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real ground.v(quantity = "ElectricPotential", unit = "V") "Potential at the pin";
  Real ground.i(quantity = "ElectricCurrent", unit = "A") "Current flowing into the pin";
  Real spacePhasor.v_[1](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
  Real spacePhasor.v_[2](quantity = "ElectricPotential", unit = "V") "1=real, 2=imaginary part";
  Real spacePhasor.i_[1](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
  Real spacePhasor.i_[2](quantity = "ElectricCurrent", unit = "A") "1=real, 2=imaginary part";
equation
  v[1] / turnsRatio = plug_p.pin[1].v - plug_n.pin[1].v;
  v[2] / turnsRatio = plug_p.pin[2].v - plug_n.pin[2].v;
  v[3] / turnsRatio = plug_p.pin[3].v - plug_n.pin[3].v;
  i[1] * turnsRatio = plug_p.pin[1].i;
  i[2] * turnsRatio = plug_p.pin[2].i;
  i[3] * turnsRatio = plug_p.pin[3].i;
  i[1] * turnsRatio = -plug_n.pin[1].i;
  i[2] * turnsRatio = -plug_n.pin[2].i;
  i[3] * turnsRatio = -plug_n.pin[3].i;
  /*Real*/(m) * zero.v = v[1] + v[2] + v[3];
  spacePhasor.v_[1] = TransformationMatrix[1,1] * v[1] + TransformationMatrix[1,2] * v[2] + TransformationMatrix[1,3] * v[3];
  spacePhasor.v_[2] = TransformationMatrix[2,1] * v[1] + TransformationMatrix[2,2] * v[2] + TransformationMatrix[2,3] * v[3];
  (-/*Real*/(m)) * zero.i = i[1] + i[2] + i[3];
  -spacePhasor.i_[1] = TransformationMatrix[1,1] * i[1] + TransformationMatrix[1,2] * i[2] + TransformationMatrix[1,3] * i[3];
  -spacePhasor.i_[2] = TransformationMatrix[2,1] * i[1] + TransformationMatrix[2,2] * i[2] + TransformationMatrix[2,3] * i[3];
  ground.v = 0.0;
  zero.i = 0.0;
  ground.i = 0.0;
  spacePhasor.i_[1] = 0.0;
  spacePhasor.i_[2] = 0.0;
  plug_p.pin[3].i = 0.0;
  plug_p.pin[2].i = 0.0;
  plug_p.pin[1].i = 0.0;
  plug_n.pin[3].i = 0.0;
  plug_n.pin[2].i = 0.0;
  plug_n.pin[1].i = 0.0;
end freeFOClib.Machines.Components.SpacePhasorM;
