<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>ModelicaReference.Operators</title>
<meta name="HTML-Generator" content="Dymola">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="description" content="&quot;Operators (+, der, size, ...)&quot;">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial, sans-serif; }
.modelica, .modelica * { font-size: 9pt; font-family: Courier, monospace; white-space: pre; }
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address { font-weight: normal; }
td      { border: 1px solid #808080; vertical-align: top; }
th      { border: 1px solid #808080; vertical-align: top; font-weight: bold; }
table   { border: 1px solid #808080; border-collapse: collapse; }
</style>
</head>
<body>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE Operators<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators"></a><a href="ModelicaReference.html#ModelicaReference"
>ModelicaReference</a>.Operators</h2>
<p>
</p>

<p>
In this chapter <b>operators</b> of Modelica are documented.
Elementary operators, such as "+" or "-" are overloaded and
operate on scalar and array variables. Other operators
have the same syntax as a
<a href="ModelicaReference_Classes.html#ModelicaReference.Classes.'function'"
>Modelica function</a>
call. However, they do not behave as a Modelica function,
either because the result depends not only on the input arguments but
also on the status of the simulation (such as "pre(..)"), or
the function operates on input arguments of different types
(such as "String(..)"). Neither of these "functions"
can be defined with a "standard" Modelica function and are
therefore builtin operators of the Modelica language
(with exception of the basic mathematical functions,
sin, cos, tan, asin, acos, atan, atan2, sinh, cosh, tanh, exp,
log, log10 that are provided for convenience as built-in functions).
</p>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Package Content</h3>
<table border="1" cellspacing="0" cellpadding="2" summary="Package Content">
<tr>
<th>Name</th>
<th>Description</th>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.ElementaryOperators" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.ElementaryOperators"
>ElementaryOperators</a>
</td>
<td>Elementary operators (+, &gt;, or, ..)</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'abs()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'abs()'"
>'abs()'</a>
</td>
<td>abs()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'acos()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'acos()'"
>'acos()'</a>
</td>
<td>acos()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'actualStream()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'actualStream()'"
>'actualStream()'</a>
</td>
<td>actualStream()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'array()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'array()'"
>'array()'</a>
</td>
<td>array()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'asin()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'asin()'"
>'asin()'</a>
</td>
<td>asin()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'assert()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'assert()'"
>'assert()'</a>
</td>
<td>assert()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'atan()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'atan()'"
>'atan()'</a>
</td>
<td>atan()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'atan2()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'atan2()'"
>'atan2()'</a>
</td>
<td>atan2()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'cardinality()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'cardinality()'"
>'cardinality()'</a>
</td>
<td>cardinality()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'cat()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'cat()'"
>'cat()'</a>
</td>
<td>cat()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'ceil()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'ceil()'"
>'ceil()'</a>
</td>
<td>ceil()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'change()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'change()'"
>'change()'</a>
</td>
<td>change()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'connect()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'connect()'"
>'connect()'</a>
</td>
<td>connect()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'Connections.branch()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'Connections.branch()'"
>'Connections.branch()'</a>
</td>
<td>Connections.branch()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'Connections.root()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'Connections.root()'"
>'Connections.root()'</a>
</td>
<td>Connections.root()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'Connections.potentialRoot()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'Connections.potentialRoot()'"
>'Connections.potentialRoot()'</a>
</td>
<td>Connection.potentialRoot()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'Connections.isRoot()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'Connections.isRoot()'"
>'Connections.isRoot()'</a>
</td>
<td>Connections.isRoot()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'Connections.rooted()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'Connections.rooted()'"
>'Connections.rooted()'</a>
</td>
<td>Connections.rooted()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'cos()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'cos()'"
>'cos()'</a>
</td>
<td>cos()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'cosh()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'cosh()'"
>'cosh()'</a>
</td>
<td>cosh()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'cross()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'cross()'"
>'cross()'</a>
</td>
<td>cross()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'delay()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'delay()'"
>'delay()'</a>
</td>
<td>delay()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'der()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'der()'"
>'der()'</a>
</td>
<td>der()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'diagonal()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'diagonal()'"
>'diagonal()'</a>
</td>
<td>diagonal()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'div()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'div()'"
>'div()'</a>
</td>
<td>div()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'edge()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'edge()'"
>'edge()'</a>
</td>
<td>edge()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'exp()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'exp()'"
>'exp()'</a>
</td>
<td>exp()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'fill()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'fill()'"
>'fill()'</a>
</td>
<td>fill()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'floor()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'floor()'"
>'floor()'</a>
</td>
<td>floor()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'homotopy()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'homotopy()'"
>'homotopy()'</a>
</td>
<td>homotopy()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'identity()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'identity()'"
>'identity()'</a>
</td>
<td>identity()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'initial()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'initial()'"
>'initial()'</a>
</td>
<td>initial()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'inStream()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'inStream()'"
>'inStream()'</a>
</td>
<td>inStream()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'Integer()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'Integer()'"
>'Integer()'</a>
</td>
<td>Integer()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'integer()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'integer()'"
>'integer()'</a>
</td>
<td>integer()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'inverse()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'inverse()'"
>'inverse()'</a>
</td>
<td>inverse()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'linspace()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'linspace()'"
>'linspace()'</a>
</td>
<td>linspace()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'log()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'log()'"
>'log()'</a>
</td>
<td>log()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'log10()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'log10()'"
>'log10()'</a>
</td>
<td>log10()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'matrix()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'matrix()'"
>'matrix()'</a>
</td>
<td>matrix()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'max()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'max()'"
>'max()'</a>
</td>
<td>max()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'min()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'min()'"
>'min()'</a>
</td>
<td>min()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'mod()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'mod()'"
>'mod()'</a>
</td>
<td>mod()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'ndims()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'ndims()'"
>'ndims()'</a>
</td>
<td>ndims()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'noEvent()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'noEvent()'"
>'noEvent()'</a>
</td>
<td>noEvent()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'ones()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'ones()'"
>'ones()'</a>
</td>
<td>ones()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'outerProduct()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'outerProduct()'"
>'outerProduct()'</a>
</td>
<td>outerProduct()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'pre()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'pre()'"
>'pre()'</a>
</td>
<td>pre()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'product()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'product()'"
>'product()'</a>
</td>
<td>product()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'reinit()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'reinit()'"
>'reinit()'</a>
</td>
<td>reinit()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'rem()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'rem()'"
>'rem()'</a>
</td>
<td>rem()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'rooted()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'rooted()'"
>'rooted()'</a>
</td>
<td>rooted() - deprecated</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'sample()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'sample()'"
>'sample()'</a>
</td>
<td>sample()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'scalar()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'scalar()'"
>'scalar()'</a>
</td>
<td>scalar()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'semiLinear()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'semiLinear()'"
>'semiLinear()'</a>
</td>
<td>semiLinear()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'sign()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'sign()'"
>'sign()'</a>
</td>
<td>sign()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'sin()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'sin()'"
>'sin()'</a>
</td>
<td>sin()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'sinh()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'sinh()'"
>'sinh()'</a>
</td>
<td>sinh()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'size()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'size()'"
>'size()'</a>
</td>
<td>size()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'skew()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'skew()'"
>'skew()'</a>
</td>
<td>skew()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'smooth()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'smooth()'"
>'smooth()'</a>
</td>
<td>smooth()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'sqrt()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'sqrt()'"
>'sqrt()'</a>
</td>
<td>sqrt()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'String()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'String()'"
>'String()'</a>
</td>
<td>String()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'sum()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'sum()'"
>'sum()'</a>
</td>
<td>sum()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'symmetric()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'symmetric()'"
>'symmetric()'</a>
</td>
<td>symmetric()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'tan()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'tan()'"
>'tan()'</a>
</td>
<td>tan()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'tanh()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'tanh()'"
>'tanh()'</a>
</td>
<td>tanh()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'terminal()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'terminal()'"
>'terminal()'</a>
</td>
<td>terminal()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'terminate()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'terminate()'"
>'terminate()'</a>
</td>
<td>terminate()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'transpose()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'transpose()'"
>'transpose()'</a>
</td>
<td>transpose()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'vector()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'vector()'"
>'vector()'</a>
</td>
<td>vector()</td>
</tr>
<tr>
<td><img src="ModelicaReference.Annotate05430efc443177cValueS.png" alt="ModelicaReference.Operators.'zeros()'" width="20" height="20" align="top">&nbsp;<a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'zeros()'"
>'zeros()'</a>
</td>
<td>zeros()</td>
</tr>
</table>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE ElementaryOperators<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.ElementaryOperators" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.ElementaryOperators"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.ElementaryOperators</h2>

<p>
Elementary operators are overloaded and operate on variables
of type Real, Integer, Boolean, and String, as well as on scalars
or arrays.
</p>
<h4>Syntax</h4>

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td colspan="3"><b>Arithmetic Operators (operate on Real, Integer scalars or arrays)</b></td>
  <tr><td><i>Operators</i></td>
      <td><i>Example</i></td>
      <td><i>Description</i></td>
      </tr>
  <tr><td>+, -, .+, .-</td>
      <td>a + b<br>
          a .+ b</td>
      <td>addition and subtraction; element-wise on arrays</td></tr>

  <tr><td>*</td>
      <td>a * b</td>
      <td>multiplication;<br>
          scalar*array: element-wise multiplication<br>
          vector*vector: element-wise multiplication (result: scalar)<br>
          matrix*matrix: matrix product <br>
          vector*matrix: row-matrix*matrix (result: vector)<br>
          matrix*vector: matrix*column-matrix (result: vector)</td></tr>
  <tr><td>/</td>
      <td>a / b</td>
      <td>division of two scalars or an array by a scalar;<br>
          division of an array by a scalar is defined element-wise.<br>
          The result is always of real type. In order to get integer <br>
          division with truncation use the function div.</td></tr>

  <tr><td>^</td>
      <td>a^b</td>
      <td>scalar power or integer power of a square matrix</td></tr>

  <tr><td>.*, ./, .^</td>
      <td>a .* b</td>
      <td>element-wise multiplication, division and exponentiation of
          scalars and arrays</td></tr>

  <tr><td>=</td>
      <td>a * b = c + d</td>
      <td>equal operator of an equation; element-wise on arrays</td></tr>
  <tr><td>:=</td>
      <td>a := c + d</td>
      <td>assignment operator; element-wise on arrays</td></tr>
</table>

&nbsp;

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td colspan="3"><b>Relational Operators (operate on Real, Integer, Boolean, String scalars)</b></td>
  <tr><td><i>Operators</i></td>
      <td><i>Example</i></td>
      <td><i>Description</i></td>
      </tr>
  <tr><td>==</td>
      <td>a == b</td>
      <td>equal; for strings: identical characters</td></tr>
  <tr><td>&lt;&gt;</td>
      <td>a &lt;&gt; b</td>
      <td>not equal; for strings: a is lexicographically less than b</td></tr>
  <tr><td>&lt;</td>
      <td>a &lt; b</td>
      <td>less than</td></tr>
  <tr><td>&lt;=</td>
      <td>a &lt;= b</td>
      <td>less than or equal</td></tr>
  <tr><td>&gt;</td>
      <td>a &gt; b</td>
      <td>greater than</td></tr>
  <tr><td>&gt;=</td>
      <td>a &gt;= b</td>
      <td>greater than or equal</td></tr>
</table>

&nbsp;

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td colspan="3"><b>Boolean Operators (operate on scalars or element-wise on arrays)</b></td>
  <tr><td><i>Operators</i></td>
      <td><i>Example</i></td>
      <td><i>Description</i></td>
      </tr>
  <tr><td><b>and</b></td>
      <td>a <b>and</b> b</td>
      <td>logical and</td></tr>
  <tr><td><b>or</b></td>
      <td>a <b>or</b> b</td>
      <td>logical or</td></tr>
  <tr><td><b>not</b></td>
      <td><b>not</b> a</td>
      <td>logical not</td></tr>
</table>

&nbsp;

<table border=1 cellspacing=0 cellpadding=2>
  <tr><td colspan="3"><b>Other Operators</b></td>
  <tr><td><i>Operators</i></td>
      <td><i>Example</i></td>
      <td><i>Description</i></td>
      </tr>
  <tr><td>[..]</td>
      <td>[1,2;3,4]</td>
      <td>Matrix constructor; "," separates rows, ";" separates columns</td></tr>
  <tr><td>{..}</td>
      <td>{{1,2}, {3,4}}</td>
      <td>Array constructor; every {..} adds one dimension</td></tr>
  <tr><td>"..."</td>
      <td>"string value"<br>
          "string "value""</td>
      <td>String literal (" is used inside a string for ")</td></tr>
  <tr><td>+</td>
      <td>"abc" + "def"</td>
      <td>Concatenation of string scalars or arrays</td></tr>
</table>

<p>Operator precedence determines the order of evaluation of operators in an expression. An operator with higher precedence is evaluated before an operator with lower precedence in the same expression.</p>

<p>The following table presents all the expression operators in order of precedence from highest to lowest. All operators are binary except exponentiation, the postfix operators and those shown as unary together with <i>expr</i>, the conditional operator, the array construction operator {} and concatenation operator [ ], and the array range constructor which is either binary or ternary. Operators with the same precedence occur at the same line of the table:</p>

<table border="1" cellpadding="1" cellspacing="1">
    <tr>
      <td><i>Operator Group</i></td>
      <td><i>Operator Syntax</i></td>
      <td><i>Examples</i></td>
    </tr>
    <tr>
      <td>postfix array index operator</td>
      <td><code>[]</code></td>
      <td><code>arr[index]</code></td>
    </tr>
    <tr>
      <td>postfix access operator</td>
      <td><code>.</code></td>
      <td><code>a.b</code></td>
    </tr>
    <tr>
      <td>postfix function call</td>
      <td><i>funcName(function-arguments)</i></td>
      <td><code>sin(4.36)</code></td>
    </tr>
    <tr>
      <td>array construct/concat</td>
      <td>{<i>expressions</i>}<br>
          [<i>expressions</i>]<br>
          [<i>expressions</i>; <i>expressions</i>...]
      </td>
      <td><code>{2,3}<br>[5,6]<br>[2,3; 7,8]</code></td>
    </tr>
    <tr>
      <td>exponentiation</td>
      <td><code>^</code></td>
      <td><code>2^3</code></td>
    </tr>
    <tr>
      <td>multiplicative and<br> array elementwise multiplicative</td>
      <td><code>*&nbsp;&nbsp;/&nbsp;&nbsp;.*&nbsp;&nbsp;./</code></td>
      <td><code>2*3&nbsp;&nbsp; 2/3<br>
                [1,2;3,4].*[2,3;5,6]</code></td>
    </tr>
    <tr>
      <td>additive and<br> array elementwise additive</td>
      <td><code>+&nbsp;&nbsp;-&nbsp;&nbsp;+<i>expr</i>&nbsp;&nbsp;-<i>expr</i><br>
                .+&nbsp;&nbsp;.-</code></td>
      <td><code>a+b, a-b, +a, -a<br>
                [1,2;3,4].+[2,3;5,6]</code</td>
    </tr>
    <tr>
      <td>relational</td>
      <td><code>&lt;&nbsp;&nbsp;&lt;=&nbsp;&nbsp;&gt;&nbsp;&nbsp;&gt;=&nbsp;&nbsp;==&nbsp;&nbsp;&lt;&gt;</code></td>
      <td><code>a&lt;b,&nbsp;a&lt;=b, a&gt;b, ...</code></td>
    </tr>
    <tr>
      <td><code>...</code></td>
      <td></td>
      <td></td>
    </tr>
    <tr>
      <td>unary negation</td>
      <td><code>not&nbsp;<i>expr</i></code></td>
      <td><code>not b1</code></td>
    </tr>
    <tr>
      <td>logical and</td>
      <td><code>and</code></td>
      <td><code>b1 and b2</code></td>
    </tr>
    <tr>
      <td>logical or<</td>
      <td><code>or</code></td>
      <td><code>b1 or b2</code</td>
    </tr>
    <tr>
      <td>array range</td>
      <td><i>expr</i>&nbsp;<code>:</code>&nbsp;<i>expr</i>&nbsp;<code>:</code>&nbsp;<i>expr</i></td>
      <td><code>1:5:100</code>, start:step:stop</td>
    </tr>
    <tr>
      <td>conditional</td>
      <td><code>if</code>&nbsp;<i>expr</i>&nbsp;<code>then</code>&nbsp;<i>expr</i>&nbsp;<code>else</code>&nbsp;<i>expr</i></td>
      <td><code>if b then 3 else x</code></td>
    </tr>
    <tr>
      <td>named argument</td>
      <td><i>ident&nbsp;</i><code>=</code>&nbsp;<i>expr</i></td>
      <td><code>x = 2.26</code></td>
    </tr>
</table>
<p>The conditional operator may also include <code>elseif</code>-clauses. Equality <code>=</code> and assignment <code>:=</code> are not expression operators since they are allowed only in equations and in assignment statements respectively. All binary expression
operators are left associative.</p>

<p>Note, the unary minus and plus in Modelica
is slightly different than in Mathematica (Mathematica is a registered trademark
of Wolfram Research Inc.) and in MATLAB (MATLAB is a registered trademark of MathWorks Inc.),
since the following expressions are illegal (whereas in
Mathematica and in MATLAB these are valid expressions):
</p>

<pre>  2*-2   // = -4 in Mathematica/MATLAB; is illegal in Modelica
  --2    // =  2 in Mathematica/MATLAB; is illegal in Modelica
  ++2    // =  2 in Mathematica/MATLAB; is illegal in Modelica
  2--2   // =  4 in Mathematica/MATLAB; is illegal in Modelica
</pre>


<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'abs()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'abs()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'abs()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'abs()'</h2>

<p>
Absolute value of Real or Integer variable.
</p>
<h4>Syntax</h4>
<blockquote><code><b>abs</b>(v)</code></blockquote>
<h4>Description</h4>
<P>Is expanded into &quot;noEvent(<B>if </B>v &ge; 0
<B>then</B> v <B>else</B> -v)&quot;. Argument v
needs to be an Integer or Real expression. </P>
<h4>Examples</h4>
<pre>
  <b>abs</b>({-3, 0, 3})
 = {3, 0, 3}</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'acos()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'acos()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'acos()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'acos()'</h2>

<p>
Trigonometric inverse cosine function
</p>
<h4>Syntax</h4>
<blockquote><code><b>acos</b>(u)</code></blockquote>
<h4>Description</h4>

<p>Returns the inverse of cos of u, with -1 &le; u &le; +1.
Argument u needs to be an Integer or Real expression.</p>

<p>
The acos function can also be accessed as Modelica.Math.acos.
</p>

<img src="../Resources/Images/acos.png" alt="acos">

<h4>Examples</h4>
<pre><b>acos</b>(0)
 = 1.5707963267949</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'actualStream()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'actualStream()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'actualStream()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'actualStream()'</h2>

<p>
The <code><strong>actualStream</strong>(v)</code> operator is provided for convenience, in order to return the actual value of the stream variable, depending on the actual flow direction. The only argument of this built-in operator needs to be a reference to a stream variable. The operator is vectorizable, in the case of vector arguments. For the following definition it is assumed that an (inside or outside) connector <code>c</code> contains a stream variable <code>h_outflow</code> which is associated with a flow variable <code>m_flow</code> in the same connector <code>c</code>:</p>

<pre>
<strong>actualStream</strong>(port.h_outflow) = <strong>if</strong> port.m_flow &gt; 0 <strong>then inStream</strong>(port.h_outflow)
                                                  <strong>else</strong> port.h_outflow;
</pre>


<h4>Example</h4>
<p>
The <code><strong>actualStream</strong>(v)</code> operator is typically used in two contexts:
</p>
<pre>
der(U) = c.m_flow*actualStream(c.h_outflow); // (1)energy balance equation
h_port = actualStream(port.h);               // (2)monitoring the enthalpy at a port
</pre>
<p>
In the case of equation (1), although the  <code><strong>actualStream()</strong></code> operator is discontinuous, the product with the flow variable is not, because <code><strong>actualStream())</strong></code> is discontinuous when the flow is zero by construction.
Therefore, a tool might infer that the expression is  <code><strong>smooth(0, ...)</strong></code> automatically, and decide whether or not to generate an event.
If a user wants to avoid events entirely, he/she may enclose the right-hand side of (1) with the  <code><strong>noEvent()</strong></code> operator.
</p>
<p>
Equations like (2) might be used for monitoring purposes (e.g. plots), in order to inspect what the <em>actual</em> enthalpy of the fluid flowing through a port is.
In this case, the user will probably want to see the change due to flow reversal at the exact instant, so an event should be generated.
If the user does not bother, then he/she should enclose the right-hand side of (2) with  <code><strong>noEvent()</strong></code>.
Since the output of <code><strong>actualStream()</strong></code> will be discontinuous, it should not be used by itself to model physical behaviour (e.g., to compute densities used in momentum balances) -  <code><strong>inStream()</strong></code> should be used for this purpose.The operator  <code><strong>actualStream()</strong></code> should be used to model physical behaviour only when multiplied by the corresponding flow variable (like in the above energy balance equation), because this removes the discontinuity.
</p>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'array()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'array()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'array()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'array()'</h2>

<p>
The constructor function <code>array(A,B,C,...)</code> constructs an array from its arguments.
</p>

<h4>Examples</h4>

<pre>
{1,2,3} <em>is a 3-vector of type Integer</em>
{{11,12,13}, {21,22,23}} <em>is a 2x3 matrix of type Integer</em>
{{{1.0, 2.0, 3.0}}} <em>is a 1x1x3 array of type Real</em>

Real[3] v = array(1, 2, 3.0);
<strong>type</strong> Angle = Real(unit="rad");
<strong>parameter</strong> Angle alpha = 2.0; // type of alpha is Real.
// array(alpha, 2, 3.0) or {alpha, 2, 3.0} is a 3-vector of type Real.
Angle[3] a = {1.0, alpha, 4}; // type of a is Real[3].
</pre>

<h4>Description</h4>

The constructor function <code>array(A,B,C,...)</code> constructs an array from its arguments according to the following
rules:
<ul>
<li>Size matching: All arguments must have the same sizes, i.e., <code>size(A)=size(B)=size(C)=...</code></li>
<li>All arguments must be type compatible expressions giving the type of the elements. The data type of the result array is the maximally expanded type of the arguments. Real and Integer subtypes can be mixed resulting in a Real result array where the Integer numbers have been transformed to Real numbers.</li>
<li>Each application of this constructor function adds a one-sized dimension to the left in the result compared to the dimensions of the argument arrays, i.e., <code>ndims(array(A,B,C)) = ndims(A) + 1 = ndims(B) + 1, ...</code></li>
<li><code>{A, B, C, ...}</code> is a shorthand notation for <code>array(A, B, C, ...)</code>.</li>
<li>There must be at least one argument [i.e., <code>array()</code> or <code>{}</code> are not defined].
</ul>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'asin()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'asin()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'asin()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'asin()'</h2>

<p>
Trigonometric inverse sine function
</p>
<h4>Syntax</h4>
<blockquote><code><b>asin</b>(u)</code></blockquote>
<h4>Description</h4>

<p>Returns the inverse of sin of u, with -1 &le; u &le; +1.
Argument u needs to be an Integer or Real expression.</p>

<p>
The asin function can also be accessed as Modelica.Math.asin.
</p>

<img src="../Resources/Images/asin.png" alt="asin">

<h4>Examples</h4>
<pre><b>asin</b>(0)
 = 0.0</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'assert()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'assert()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'assert()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'assert()'</h2>

<p>
Trigger error and print error message if assertion condition is not fulfilled
</p>
<h4>Syntax</h4>
<blockquote><code><b>assert</b>(condition, message, level = AssertionLevel.error)</code></blockquote>
<h4>Description</h4>
<p>The Boolean expression <i>condition</i> shall be true for successful model evaluations.
Otherwise, an error occurs using the string expression <i>message</i>
as error message.</p>
<P>If the condition of an assert statement is true, message is not
evaluated and the procedure call is ignored. If the condition
evaluates to false different actions are taken depending on the level input:
</p>

<ul>
<li> level = AssertionLevel.error:<br>
     The current evaluation is aborted. The simulation may
     continue with another evaluation [e.g., with a shorter step-size,
     or by changing the values of iteration variables].
     If the simulation is aborted, message indicates the cause of the
     error. Failed assertions takes precedence over successful
     termination, such that if the model first triggers the
     end of successful analysis by reaching the stop-time
     or explicitly with terminate(), but the evaluation with
     terminal()=true triggers an assert, the analysis failed. </li>
<li> level = AssertionLevel.warning:<br>
     The current evaluation is not aborted. message indicates
     the cause of the warning [It is recommended to report the
     warning only once when the condition becomes false, and it is
     reported that the condition is no longer violated when the
     condition returns to true. The assert(..) statement shall
     have no influence on the behavior of the model.
     For example, by evaluating the condition and reporting the
     message only after accepted integrator steps. condition
     needs to be implicitly treated with noEvent(..) since
     otherwise events might be triggered that can lead to slightly
     changed simulation results].</li>
</ul>

<p>
The AssertionLevel.error case can be used to avoid evaluating a model outside its limits of validity; for instance, a function to compute the saturated liquid temperature cannot be called with a pressure lower than the triple point value.
The AssertionLevel.warning case can be used when the boundary of validity is not hard: for instance, a fluid property model based on a polynomial interpolation curve might give accurate results between temperatures of 250 K and 400 K, but still give reasonable results in the range 200 K and 500 K. When the temperature gets out of the smaller interval, but still stays in the largest one, the user should be warned, but the simulation should continue without any further action. The corresponding code would be
</p>
<pre>  <b>assert</b>(T &gt; 250 and T &lt; 400, "Medium model outside full accuracy range",
         AssertionLevel.warning);
  <b>assert</b>(T &gt; 200 and T &lt; 500, "Medium model outside feasible region");
</pre>

<h4>Examples</h4>
<pre>  <b>parameter</b> Real upperLimit=2;
  <b>parameter</b> Real lowerLimit=-2;
<b>equation</b>
  <b>assert</b>(upperLimit > lowerLimit, "upperLimit must be greater than lowerLimit.");
</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'atan()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'atan()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'atan()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'atan()'</h2>

<p>
Trigonometric inverse tangent function
</p>
<h4>Syntax</h4>
<blockquote><code><b>atan</b>(u)</code></blockquote>
<h4>Description</h4>

<p>Returns the inverse of tan of u, with -&infin; &lt; u &lt; &infin;.
Argument u needs to be an Integer or Real expression.</p>

<p>
The atan function can also be accessed as Modelica.Math.atan.
</p>

<img src="../Resources/Images/atan.png" alt="atan">

<h4>Examples</h4>
<pre><b>atan</b>(1)
 = 0.785398163397448</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'atan2()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'atan2()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'atan2()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'atan2()'</h2>

<p>
Four quadrant inverse tangent
</p>
<h4>Syntax</h4>
<blockquote><pre><b>atan2</b>(u1,u2)</pre></blockquote>
<h4>Description</h4>

<p>
Returns y = atan2(u1,u2) such that tan(y) = u1/u2 and
y is in the range -pi &lt; y &le; pi. u2 may be zero, provided
u1 is not zero. Usually u1, u2 is provided in such a form that
u1 = sin(y) and u2 = cos(y).
Arguments u1 and u2 need to be Integer or Real expressions.
</p>

<p>
The atan2 function can also be accessed as Modelica.Math.atan2.
</p>

<img src="../Resources/Images/atan2.png" alt="atan2">

<h4>Examples</h4>
<pre><b>atan2</b>(1,0)
 = 1.5707963267949</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'cardinality()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'cardinality()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'cardinality()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'cardinality()'</h2>

<p>
Number of connectors in connection.
This is a deprecated operator. It should  no longer be used, since it will be removed in one of the next Modelica releases.
</p>

<h4>Syntax</h4>
<blockquote><pre><b>cardinality</b>(c)</pre></blockquote>
<h4>Description</h4>
<p>Returns the number of (inside and outside) occurrences
of connector instance c in a connect statement as an Integer number.</p>
<p><i>[The cardinality operator allows the definition of connection dependent equations in a model.]</i></p>

<p>
Instead of the cardinality(..) operator, often conditional
connectors can be used, that are enabled/disabled via Boolean
parameters.
</p>

<h4>Examples</h4>
<PRE><B>connector</B> Pin
  Real      v;
  <B>flow</B> Real i;
<B>end</B> Pin;
<B>model</B> Resistor
   <B>Pin</B> p, n;
<B>equation</B>
   // Handle cases if pins are not connected
      <B>if cardinality</B>(p) == 0 <B>and cardinality</B>(n) == 0 <B>then</B>
         p.v = 0;
         n.v = 0;
      <B>elseif cardinality</B>(p) == 0 <B>then</B>
         p.i = 0;
      <B>elseif cardinality</B>(n) == 0 <B>then</B>
         n.i = 0;
      <B>end if</B>;
   // Equations of resistor
      ...
<B>end</B> Resistor;</PRE>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'cat()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'cat()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'cat()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'cat()'</h2>

<p>
The function <code>cat(k,A,B,C,...)</code>concatenates arrays <code>A,B,C,...</code> along dimension <code>k</code>.
</p>

<h4>Examples</h4>

<pre>
Real[2,3] r1 = cat(1, {{1.0, 2.0, 3}}, {{4, 5, 6}});
Real[2,6] r2 = cat(2, r1, 2*r1);
</pre>

<h4>Description</h4>

The function <code>cat(k,A,B,C,...)</code>concatenates arrays <code>A,B,C,...</code> along dimension <code>k</code> according to the following rules:
<ul>
<li>Arrays <code>A, B, C, ...</code> must have the same number of dimensions, i.e., <code>ndims(A) = ndims(B) = ...</code></li>
<li>Arrays <code>A, B, C, ...</code> must be type compatible expressions giving the type of the elements of the result. The maximally expanded types should be equivalent. Real and Integer subtypes can be mixed resulting in a Real result array where the Integer numbers have been transformed to Real numbers.</li>
<li><code>k</code> has to characterize an existing dimension, i.e., <code>1 &lt;= k &lt;= ndims(A) = ndims(B) = ndims(C)</code>; <code>k</code> shall be an integer number.</li>
<li>Size matching: Arrays <code>A, B, C, ...</code> must have identical array sizes with the exception of the size of dimension <code>k</code>, i.e., <code>size(A,j) = size(B,j), for 1 &lt;= j &lt;= ndims(A) and j &lt;&gt; k</code>.</li>
</ul>

<p>Concatenation is formally defined according to:</p>
<pre>
Let R = cat(k,A,B,C,...), and let n = ndims(A) = ndims(B) = ndims(C) = ...., then
size(R,k) = size(A,k) + size(B,k) + size(C,k) + ...
size(R,j) = size(A,j) = size(B,j) = size(C,j) = ...., for 1 &lt;= j &lt;= n and j &lt;&gt; k.
R[i_1, ..., i_k, ..., i_n] = A[i_1, ..., i_k, ..., i_n], for i_k &lt;= size(A,k),
R[i_1, ..., i_k, ..., i_n] = B[i_1, ..., i_k - size(A,i), ..., i_n], for i_k &lt;= size(A,k) + size(B,k),
....
where 1 &lt;= i_j &lt;= size(R,j) for 1 &lt;= j &lt;= n.
</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'ceil()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'ceil()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'ceil()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'ceil()'</h2>

<p>
Round a Real number towards plus infinity
</p>
<h4>Syntax</h4>
<blockquote><pre><b>ceil</b>(x)</pre></blockquote>
<h4>Description</h4>
<p>Returns the smallest integer not less than <code>x</code>.
Result and argument shall have type Real.
<i>[Note, outside of a when clause state events are
triggered when the return value changes discontinuously.]</i></p>
<h4>Examples</h4>
<pre><b>ceil</b>({-3.14, 3.14})
 = {-3.0, 4.0}</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'change()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'change()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'change()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'change()'</h2>

<p>
Indicate discrete variable changing
</p>
<h4>Syntax</h4>
<blockquote><pre><b>change</b>(v)</pre></blockquote>
<h4>Description</h4>
<P>Is expanded into &quot;(v&lt;&gt;pre(v))&quot;.
The same restrictions as for the pre() operator apply.</P>
<h4>Examples</h4>
<pre><b>model</b> BothEdges
  Boolean u;
  Integer i;
<b>equation</b>
  u = Modelica.Math.sin(<b>time</b>) &gt; 0.5;
  <b>when</b> <b>change</b>(u) <b>then</b>
    i = <b>pre</b>(i) + 1;
  <b>end when</b>;
<b>end</b> BothEdges;</pre>

<img src="../Resources/Images/change.png" width="400" height="280" alt="Simulation result">

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'connect()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'connect()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'connect()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'connect()'</h2>

<p>
Connect objects (defines <em>breakable</em> branches)
</p>
<h4>Examples</h4>

<pre><b>model</b> Integrate
  Modelica.Blocks.Sources.Step step;
  Modelica.Blocks.Continuous.Integrator integrator;
<b>equation</b>
  connect(step.outPort, integrator.inPort);
<b>end</b> Integrate;</pre>

<p>Example of array use:</p>

<pre><B>connector</B> InPort = <B>input</B> Real;

<B>connector</B> OutPort = <B>output</B> Real;

<B>block</B> MatrixGain
  <B>input</B> InPort u[size(A,1)];
  <B>output</B> OutPort y[size(A,2)]
  <B>parameter</B> Real A[:,:]=[1];
<B>equation</B>
  y=A*u;
<B>end</B> MatrixGain;

  sin sinSource[5];
  MatrixGain gain(A=5*identity(5));
  MatrixGain gain2(A=ones(5,2));
  OutPort x[2];
<B>equation</B>
  <B>connect</B>(sinSource.y, gain.u); // Legal
  <B>connect</B>(gain.y, gain2.u);     // Legal
  <B>connect</B>(gain2.y, x);          // Legal</pre>

<h4>Syntax</h4>

<PRE>equation_clause :
  [ <B>initial</B> ] <B>equation</B> { equation ";" | annotation  ";" }

equation :
  ( simple_expression "=" expression
    | conditional_equation_e
    | for_clause_e
    | connect_clause
    | when_clause_e
    | IDENT function_call )
  comment

connect_clause :
  <B>connect</B> "(" component_reference "," component_reference ")"</PRE>

<h4>Description</h4>

<P>Connections between objects are introduced by the <B>connect</B>
statement in the equation part of a class. The <B>connect</B>
construct takes two references to connectors, each of which is
either of the following forms:</P>

<UL>
  <LI>c1.c2. ... .cn, where c1 is a connector of the class, n&ge;1
      and ci+1 is a connector element of ci for i=1:(n-1).</LI>
  <LI>m.c, where m is a non-connector element in the class and c is
      a connector element of m.</LI>
</UL>

<P>There may optionally be array subscripts on any of the components;
the array subscripts shall be parameter expressions. If the connect
construct references array of connectors, the array dimensions must
match, and each corresponding pair of elements from the arrays is
connected as a pair of scalar connectors.</P>

<P>The two main tasks are to:</P>

<UL>
  <LI>Build connection sets from <B>connect </B>statements.</LI>
  <LI>Generate equations for the complete model.</LI>
</UL>

<P>Definitions:</P>

<ul>
  <li>Connection sets<br>
      A connection set is a set of variables connected by means of
      connect clauses. A connection set shall contain either only flow
      variables or only non-flow variables.</li>
  <li>Inside and outside connectors<br>
      In an element instance M, each connector element of M is called
      an outside connector with respect to M. All other connector elements
      that are hierarchically inside M, but not in one of the outside
      connectors of M, is called an inside connector with respect to M.<br>
      <i>[Example: in connect(a,b.c) 'a' is an outside connector and 'b.c'
      is an inside connector, unless 'b' is a connector.]</i></li>
</ul>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'Connections.branch()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'Connections.branch()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'Connections.branch()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'Connections.branch()'</h2>

<p>
Defines <em>non-breakable</em> branch
</p>

<h4>Syntax</h4>
<pre>
Connections.branch(A.R,B.R);
</pre>

<h4>Description</h4>
<p>
Defines a non-breakable branch from the overdetermined type or record instance <code>R</code> in connector instance <code>A</code> to the corresponding overdetermined type or record instance <code>R</code> in connector instance <code>B</code> for a virtual connection graph.
</p>
<h4>Examples</h4>
<p>
This function can be used at all places where a <a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'connect()'"
>connect(...)</a> statement is allowed.
</p>
<p>
E.g., it is not allowed to use this function in a when-clause.
This definition shall be used if in a model with connectors <code>A</code> and <code>B</code> the overdetermined records <code>A.R</code> and <code>B.R</code> are algebraically coupled in the model, e.g., due to <code>B.R = f(A.R, &lt;other unknowns&gt;)</code>.
</p>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'Connections.root()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'Connections.root()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'Connections.root()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'Connections.root()'</h2>

<p>
Defines a <em>definite</em> root node.
</p>
<h4>Syntax</h4>
<pre>
Connections.root(A.R);
</pre>

<h4>Description</h4>
<p>
The overdetermined type or record instance <code>R</code> in connector instance <code>A</code> is a (definite) root node in a virtual connection graph.
</p>

<h4>Examples</h4>
<p>
This definition shall be used if in a model with connector <code>A</code> the overdetermined record <code>A.R</code> is (consistently) assigned, e.g.,  from a parameter expressions.
</p>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'Connections.potentialRoot()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'Connections.potentialRoot()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'Connections.potentialRoot()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'Connections.potentialRoot()'</h2>

<p>
Defines a <em>potential</em> root node.
</p>
<h4>Syntax</h4>
<pre>
Connections.potentialRoot(A.R);
Connections.potentialRoot(A.R, priority = p);
</pre>

<h4>Description</h4>
<p>
The overdetermined type or record instance <code>R</code> in connector instance <code>A</code> is a potential root node in a virtual connection graph with priority <code>p</code> (with <code>p &ge; 0</code>).
If no second argument is provided, the priority is zero. <code>p</code> shall be a parameter expression of type Integer.
In a virtual connection subgraph without a  <a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'Connections.root()'"
>Connections.root()</a> definition, one of the potential roots with the lowest priority number is selected as root.
</p>

<h4>Examples</h4>
<p>
This definition may  be used if in a model with connector <code>A</code> the overdetermined record <code>A.R</code> appears differentiated, <code>der(A.R)</code>, together with the constraint equations of <code>A.R</code>, i.e., a non-redundant subset of <code>A.R</code> maybe used as states.
</p>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'Connections.isRoot()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'Connections.isRoot()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'Connections.isRoot()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'Connections.isRoot()'</h2>

<p>
Returns root status.
</p>
<h4>Syntax</h4>
<pre>
b = Connections.isRoot(A.R);
</pre>

<h4>Description</h4>
<p>
Returns true, if the overdetermined type or record instance <code>R</code> in connector instance <code>A</code> is selected as a root in the virtual connection graph.
</p>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'Connections.rooted()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'Connections.rooted()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'Connections.rooted()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'Connections.rooted()'</h2>

<p>
Returns which node of a connection branch is closer to root.
</p>
<h4>Syntax</h4>
<pre>
b = Connections.rooted(A.R);
b = rooted(A.R);  // deprecated
</pre>

<h4>Description</h4>
<p>
If the operator <code>Connections.rooted(A.R)</code> is used, or the equivalent <em>but deprecated</em> operator <code>rooted(A.R)</code>, then there must be exactly one statement <code>Connections.branch(A.R,B.R)</code> involving <code>A.R</code> (the argument of <code>Connections.rooted</code> must be the first argument of <code>Connections.branch</code>).
In that case <code>Connections.rooted(A.R)</code> returns <em>true</em>, if <code>A.R</code> is closer to the root of the spanning tree than <code>B.R</code>; otherwise <em>false</em> is returned.

<h4>Examples</h4>
<p>
This operator can be used to avoid equation systems by providing analytic inverses, see Modelica.Mechanics.MultiBody.Parts.FixedRotation</a>.
</p>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'cos()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'cos()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'cos()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'cos()'</h2>

<p>
Trigonometric cosine function
</p>
<h4>Syntax</h4>
<blockquote><pre><b>cos</b>(u)</pre></blockquote>
<h4>Description</h4>
<p>Returns the cosine of u, with -&infin; &lt; u &lt; &infin;
Argument u needs to be an Integer or Real expression.</p>

<p>
The cosine function can also be accessed as Modelica.Math.cos.
</p>

<img src="../Resources/Images/cos.png" alt="cos">

<h4>Examples</h4>
<pre><b>cos</b>(3.14159265358979)
 = -1.0</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'cosh()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'cosh()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'cosh()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'cosh()'</h2>

<p>
Hyperbolic cosine function
</p>
<h4>Syntax</h4>
<blockquote><pre><b>cosh</b>(u)</pre></blockquote>
<h4>Description</h4>
<p>Returns the cosh of u, with -&infin; &lt; u &lt; &infin;.
Argument u needs to be an Integer or Real expression.</p>

<p>
The cosh function can also be accessed as Modelica.Math.cosh.
</p>

<img src="../Resources/Images/cosh.png" alt="cosh">

<h4>Examples</h4>
<pre><b>cosh</b>(1)
  = 1.54308063481524</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'cross()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'cross()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'cross()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'cross()'</h2>

<p>
Return cross product of two vectors
</p>
<h4>Syntax</h4>
<blockquote><pre><b>cross</b>(x, y)</pre></blockquote>
<h4>Description</h4>
<p>
Returns the cross product of the 3-vectors x and y, i.e.
</p>
<blockquote><pre>
<b>cross</b>(x,y) = <b>vector</b>( [ x[2]*y[3]-x[3]*y[2];
                       x[3]*y[1]-x[1]*y[3];
                       x[1]*y[2]-x[2]*y[1] ] );
</pre></blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'delay()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'delay()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'delay()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'delay()'</h2>

<p>
Delay expression
</p>
<h4>Syntax</h4>
<blockquote><pre><b>delay</b>(expr, delayTime, delayMax)
<b>delay</b>(expr, delayTime)</pre></blockquote>
<h4>Description</h4>
<P>Returns <CODE>"expr(time - delayTime)"</CODE> for <CODE>time &gt; time.start + delayTime</CODE>
and <CODE>"expr(time.start)"</CODE> for <CODE>time &le; time.start + delayTime</CODE>. The
arguments, i.e., <code>expr</code>, <code>delayTime</code> and <code>delayMax</code>, need to be subtypes of Real.
<CODE>delayMax</CODE> needs to be additionally a parameter expression. The following relation
shall hold: <CODE>0 &le; delayTime &le; delayMax</code>, otherwise an error occurs. If
<code>delayMax</code> is not supplied in the argument list, <code>delayTime</code> need to be a
parameter expression.</P>
<p><i>[The <b>delay</b> operator allows a numerical sound implementation
by interpolating in the (internal) integrator polynomials, as well as a
more simple realization by interpolating linearly in a buffer containing
past values of expression expr. Without further information, the complete
time history of the delayed signals need to be stored, because the delay
time may change during simulation. To avoid excessive storage requirements
and to enhance efficiency, the maximum allowed delay time has to be given
via delayMax, or delayTime must be a parameter expression (so that the
constant delay is known before simulation starts).
This gives an upper bound on the values of the delayed
signals which have to be stored. For realtime simulation where fixed step
size integrators are used, this information is sufficient to allocate the
necessary storage for the internal buffer before the simulation starts.
For variable step size integrators, the buffer size is dynamic during
integration. In principal, a delay operator could break algebraic loops.
For simplicity, this is not supported because the minimum delay time has
to be give as additional argument to be fixed at compile time. Furthermore,
the maximum step size of the integrator is limited by this minimum delay
time in order to avoid extrapolation in the delay buffer.]</i></p>
<h4>Examples</h4>
<pre><b>model</b> Delay
  Real x;
  Real y;
<b>equation
  der</b>(x) = 2;
  y = <b>delay</b>(x, 1);
<b>end</b> Delay;</pre>

<img src="../Resources/Images/delay.png" width="400" height="280" alt="Simulation result">

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'der()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'der()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'der()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'der()'</h2>

<p>
Time derivative of expression or<br>
partial derivative of function
</p>

<h4>Syntax</h4>

<blockquote><pre><b>der</b>(expr) or
IDENT "=" <b>der</b> "(" name "," IDENT { "," IDENT } ")" comment</pre>
</blockquote>

<h4>Description</h4>
<p>
The first form is the time derivative of expression expr.
If the expression expr is a scalar it needs to be a subtype of Real. The expression and all its subexpressions must be differentiable. If expr is an array, the operator is applied to all elements of the array. For Real parameters and
constants the result is a zero scalar or array of the same size as the
variable.</p>

<p>
The second form is the partial derivative of a function
and may only be used as declarations of functions.
The semantics is that a function [and only a function] can be specified in this form, defining that it is the partial derivative of the function to the right of the equal sign (looked up in the same way as a short class definition - the looked up name must be a function), and partially differentiated with respect to each IDENT in order (starting from the first one). The IDENT must be Real inputs to the function.
The comment allows a user to comment the function (in the info-layer and as one-line description, and as icon).
</p>

<h4>Examples</h4>

<blockquote>
<pre>  Real x, xdot1, xdot2;
<b>equation</b>
  xdot1 = <b>der</b>(x);
  xdot2 = <b>der</b>(x*sin(x));
</pre>
</blockquote>

<p>
The specific enthalpy can be computed from a Gibbs-function as follows:
</p>

<blockquote>
<pre><b>function</b> Gibbs
  <b>input</b> Real p,T;
  <b>output</b> Real g;
<b>algorithm</b>
  ...
<b>end</b> Gibbs;

<b>function</b> Gibbs_T=<b>der</b>(Gibbs, T);

<b>function</b> specificEnthalpy
  <b>input</b> Real p,T;
  <b>output</b> Real h;
<b>algorithm</b>
  h:=Gibbs(p,T)-T*Gibbs_T(p,T);
<b>end</b> specificEnthalpy;
</pre>
</blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'diagonal()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'diagonal()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'diagonal()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'diagonal()'</h2>

<p>
Returns a diagonal matrix
</p>
<h4>Syntax</h4>
<blockquote><pre><b>diagonal</b>(v)</pre></blockquote>
<h4>Description</h4>
<p>
Returns a square matrix with the elements of vector v
on the diagonal and all other elements zero.
</p>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'div()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'div()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'div()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'div()'</h2>

<p>
Integer part of division of two Real numbers
</p>
<h4>Syntax</h4>
<blockquote><pre><b>div</b>(x, y)</pre></blockquote>
<h4>Description</h4>
<P>Returns the algebraic quotient <CODE>x/y</CODE> with any
fractional part discarded (also known as truncation
toward zero). <I>[Note: this is defined for / in C99;
in C89 the result for negative numbers is
implementation-defined, so the standard function
<CODE>div()</CODE> must be used.]</I> Result and arguments
shall have type Real or Integer. If either of the
arguments is Real the result is Real otherwise Integer.</P>

<p><i>[Note, outside of a when clause state events are triggered
when the return value changes discontinuously.]</i></p>

<h4>Examples</h4>
<pre><b>div</b>(13,6)
 = 2</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'edge()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'edge()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'edge()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'edge()'</h2>

<p>
Indicate rising edge
</p>
<h4>Syntax</h4>
<blockquote><pre><b>edge</b>(b)</pre></blockquote>
<h4>Description</h4>
<P>Is expanded into &quot;(b <B>and not pre</B>(b))&quot;
for Boolean variable b. The same restrictions as for the
<B>pre</B> operator apply (e.g., not to be used in function
classes).</P>
<h4>Examples</h4>
<pre><b>model</b> RisingEdge
  Boolean u;
  Integer i;
<b>equation</b>
  u = Modelica.Math.sin(<b>time</b>) &gt; 0.5;
  <b>when</b> <b>edge</b>(u) <b>then</b>
    i = <b>pre</b>(i) + 1;
  <b>end when</b>;
<b>end</b> RisingEdge;</pre>

<img src="../Resources/Images/edge.png" width="400" height="280" alt="Simulation result">

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'exp()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'exp()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'exp()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'exp()'</h2>

<p>
Exponential, base e.
</p>
<h4>Syntax</h4>
<blockquote><pre><b>exp</b>(u)</pre></blockquote>
<h4>Description</h4>
<p>Returns the base e exponential of u, with -&infin; &lt; u &lt; &infin;
Argument u needs to be an Integer or Real expression.</p>

<p>
The exponential function can also be accessed as Modelica.Math.exp.
</p>

<img src="../Resources/Images/exp.png" alt="exp">

<h4>Examples</h4>
<pre><b>exp</b>(1)
 = 2.71828182845905</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'fill()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'fill()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'fill()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'fill()'</h2>

<p>
Return a Real, Integer, Boolean or String array with all elements equal
</p>
<h4>Syntax</h4>
<blockquote><pre><b>fill</b>(s, n1, n2, n3, ...)</pre></blockquote>
<h4>Description</h4>
<p>
Returns the n1 x n2 x n3 x ... array with all elements equal
to scalar or array expression s (ni >= 0). The returned
array has the same type as s. Recursive definition:
</p>
<blockquote><pre>
fill(s,n1,n2,n3, ...) = fill(fill(s,n2,n3, ...), n1);
fill(s,n) = {s,s,..., s}
</pre></blockquote>
<h4>Examples</h4>
<blockquote><pre>
Real    mr[2,2] = fill(-1,2,2);  // = [-1,-1;-1,-1]
Boolean vb[3]   = fill(true,3);  // = {true, true, true}
</pre></blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'floor()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'floor()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'floor()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'floor()'</h2>

<p>
Round Real number towards minus infinity
</p>
<h4>Syntax</h4>
<blockquote><pre><b>floor</b>(x)</pre></blockquote>
<h4>Description</h4>
<p>Returns the largest integer not greater than <code>x</code>.
Result and argument shall have type Real. <i>[Note, outside
of a when clause state events are triggered when the return
value changes discontinuously.]</i></p>
<h4>Examples</h4>
<pre><b>floor</b>({-3.14, 3.14})
 = {-4.0, 3.0}</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'homotopy()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'homotopy()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'homotopy()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'homotopy()'</h2>

<p>
During the initialization phase of a dynamic simulation problem, it often happens that large nonlinear systems of equations must be solved by means of an iterative solver.
The convergence of such solvers critically depends on the choice of initial guesses for the unknown variables.
The process can be made more robust by providing an alternative, simplified version of the model, such that convergence is possible even without accurate initial guess values, and then by continuously transforming the simplified model into the actual model.
This transformation can be formulated using expressions of this kind:
</p>

<blockquote>
<pre>
lambda*actual + (1-lambda)*simplified
</pre>
</blockquote>

<p>
in the formulation of the system equations, and is usually called a homotopy transformation.
If the simplified expression is chosen carefully, the solution of the problem changes continuously with lambda, so by taking small enough steps it is possible to eventually obtain the solution of the actual problem.
</p>
<p>
It is recommended to perform (conceptually) one homotopy iteration over the whole model, and not several homotopy iterations over the respective non-linear algebraic equation systems.
The reason is that the following structure can be present:
</p>
<blockquote>
<pre>
<strong>w = f<sub>1</sub>(x)</strong> // has homotopy operator
<strong>0 = f<sub>2</sub>(der(x), x, z, w)</strong>
</pre>
</blockquote>
<p>
Here, a non-linear equation system <strong><code>f<sub>2</sub></code></strong> is present.
The homotopy operator is, however used on a variable that is an 'input' to the non-linear algebraic equation system, and modifies the characteristics of the non-linear algebraic equation system.
The only useful way is to perform the homotopy iteration over <strong><code>f<sub>1</sub></code></strong> and <strong><code>f<sub>2</sub></code></strong> together.
</p>
<p>
The suggested approach is 'conceptual', because more efficient implementations are possible, e.g., by determining the smallest iteration loop, that contains the equations of the first BLT block in which a homotopy operator is present and all equations up to the last BLT block that describes a non-linear algebraic equation system.
</p>
<p>
A trivial implementation of the homotopy operator is obtained by defining the following function in the globalscope:
</p>

<blockquote><pre>
<strong>function</strong> homotopy
  <strong>input</strong> Real actual;
  <strong>input</strong> Real simplified;
  <strong>output</strong> Real y;
<strong>algorithm</strong>
  y := actual;
  <strong>annotation</strong>(Inline = true);
<strong>end</strong> homotopy;
</pre></blockquote>

<h4>Syntax</h4>
<blockquote><pre>
<strong>homotopy</strong>(actual=actual, simplified=simplified)
</pre></blockquote>

<h4>Description</h4>
<p>
The scalar expressions 'actual' and 'simplified' are subtypes of Real.
A Modelica translator should map this operator into either of the two forms:
</p>
<ol>
<li> Returns 'actual' <em>[a trivial implementation]</em>.</li>
<li> <p>In order to solve algebraic systems of equations, the operator might during the solution process return a combination of the two arguments, ending at actual, <em>e.g.,</em></p>
<blockquote>
<pre><em>
actual*lambda + simplified*(1-lambda),
</em></pre>
</blockquote>
<p>where <code>lambda</code> is a homotopy parameter going from 0 to 1.</p>
<p>The solution must fulfill the equations for homotopy returning 'actual'.</p></li>
</ol>

<h4>Examples</h4>
<h5>Example 1</h5>
<p>
In electrical systems it is often difficult to solve non-linear algebraic equations if switches are part of the
algebraic loop.
An idealized diode model might be implemented in the following way, by starting with a 'flat' diode characteristic and then move with the homotopy operator to the desired 'steep' characteristic:
</p>
<blockquote><pre>
<strong>model</strong> IdealDiode
  ...
  <strong>parameter</strong> Real Goff = 1e-5;
<strong>protected</strong>
  <strong>Real</strong> Goff_flat = max(0.01, Goff);
  <strong>Real</strong> Goff2;
<strong>equation</strong>
  off = s &lt; 0;
  Goff2 = <strong>homotopy</strong>(actual=Goff, simplified=Goff_flat);
  u = s*(<strong>if</strong> off <strong>then</strong> 1     <strong>else</strong> Ron2) + Vknee;
  i = s*(<strong>if</strong> off <strong>then</strong> Goff2 <strong>else</strong> 1   ) + Goff2*Vknee;
  ...
<strong>end</strong> IdealDiode;
</pre></blockquote>

<h5>Example 2</h5>
<p>
In electrical systems it is often useful that all voltage sources start with zero voltage and all current sources with zero current, since steady state initialization with zero sources can be easily obtained.
A typical voltage source would then be defined as:
</p>

<blockquote><pre>
<strong>model</strong> ConstantVoltageSource
  <strong>extends</strong> Modelica.Electrical.Analog.Interfaces.OnePort;
  <strong>parameter</strong> Modelica.SIunits.Voltage V;
<strong>equation</strong>
  v = <strong>homotopy</strong>(actual=V, simplified=0.0);
<strong>end</strong> ConstantVoltageSource;
</pre></blockquote>

<h5>Example 3</h5>
<p>
In fluid system modelling, the pressure/flowrate relationships are highly nonlinear due to the quadratic terms and due to the dependency on fluid properties.
A simplified linear model, tuned on the nominal operating point, can be used to make the overall model less nonlinear and thus easier to solve without accurate start values.
Named arguments are used here in order to further improve the readability.
</p>

<blockquote><pre>
<strong>model</strong> PressureLoss
  <strong>import</strong> SI = Modelica.SIunits;
  ...
  <strong>parameter</strong> SI.MassFlowRate m_flow_nominal "Nominal mass flow rate";
  <strong>parameter</strong> SI.Pressure     dp_nominal     "Nominal pressure drop";
  SI.Density                rho            "Upstream density";
  SI.DynamicViscosity       lambda         "Upstream viscosity";
<strong>equation</strong>
  ...
  m_flow = <strong>homotopy</strong>(actual     = turbulentFlow_dp(dp, rho, lambda),
                    simplified = dp/dp_nominal*m_flow_nominal);
  ...
<strong>end</strong> PressureLoss;
</pre></blockquote>

<h5>Example 4</h5>
<p>
Note that the homotopy operator <strong>shall not</strong> be used to combine unrelated expressions, since this can generate singular systems from combining two well-defined systems.
</p>

<blockquote><pre>
<strong>model</strong> DoNotUse
  Real x;
  <strong>parameter</strong> Real x0 = 0;
<strong>equation</strong>
  der(x) = 1-x;
<strong>initial equation</strong>
  0 = <strong>homotopy</strong>(der(x), x - x0);
<strong>end</strong> DoNotUse;
</pre></blockquote>
<p>
The initial equation is expanded into
<blockquote><pre>
0 = lambda*der(x) + (1-lambda)*(x-x0)
</pre></blockquote>
<p>
and you can solve the two equations to give
</p>
<blockquote><pre>
x = (lambda+(lambda-1)*x0)/(2*lambda - 1)
</pre></blockquote>
<p>
which has the correct value of <code>x0</code> at <code>lambda = 0</code> and of <code>1</code> at <code>lambda = 1</code>, but unfortunately has a singularity at <code>lambda = 0.5</code>.
</p>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'identity()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'identity()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'identity()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'identity()'</h2>

<p>
Returns the identity matrix of the desired size
</p>
<h4>Syntax</h4>
<blockquote><pre><b>identity</b>(n)</pre></blockquote>
<h4>Description</h4>
<p>
Returns the n x n Integer identity matrix, with ones
on the diagonal and zeros at the other places.
</p>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'initial()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'initial()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'initial()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'initial()'</h2>

<p>
True during initialization
</p>
<h4>Syntax</h4>
<blockquote><pre><b>initial</b>()</pre></blockquote>
<h4>Description</h4>
<p>Returns <b>true</b> during the initialization phase and <b>false</b> otherwise.</p>
<h4>Examples</h4>
<pre>  Boolean off;
  Real x;
<b>equation</b>
  off = x &lt; -2 or <b>initial</b>();</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'inStream()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'inStream()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'inStream()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'inStream()'</h2>

<p>
Returns the mixing value of a stream variable if it flows into the component where the inStream operator
is used.
</p>

<p>
For an introduction into stream variables and an example for the inStream(..) operator, see
<a href="ModelicaReference.html#ModelicaReference.'stream'"
>stream</a>.
</p>

<h4>Syntax</h4>

<blockquote><pre><b>inStream</b>(IDENT) </pre>
</blockquote>

<p>
where <code>IDENT</code> must be a variable reference in a connector component declared with the
<a href="ModelicaReference.html#ModelicaReference.'stream'"
>stream</a> prefix.
</p>

<h4>Description</h4>

<p>
In combination with the stream variables of a connector, the inStream() operator
is designed to describe in a numerically reliable way the bi-directional
transport of specific quantities carried by a flow of matter. inStream(v) is
only allowed on stream variables v and is informally the value the stream
variable has, assuming that the flow is from the connection point into the
component. This value is computed from the stream connection equations of the
flow variables and of the stream variables. For the following definition it is
assumed that N inside connectors mj.c (j=1,2,...,N) and M outside connectors
ck(k=1,2,...,M) belonging to the same connection set
are connected together and a stream variable h_outflow is associated with
a flow variable m_flow in connector c.
</p>

<blockquote>
<pre><b>connector</b> FluidPort
   ...
   <b>flow</b>   Real m_flow     "Flow of matter; m_flow &gt; 0 if flow into component";
   <b>stream</b> Real h_outflow  "Specific variable in component if m_flow &lt; 0"
<b>end</b> FluidPort;

<b>model</b> FluidSystem
   ...
   FluidComponent m1, m2, ..., mN;
   FluidPort      c1, c2, ..., cM;
<b>equation</b>
   <b>connect</b>(m1.c, m2.c);
   <b>connect</b>(m1.c, m3.c);
      ...
   <b>connect</b>(m1.c, mN.c);
   <b>connect</b>(m1.c, c1);
   <b>connect</b>(m1.c, c2);
      ...
   <b>connect</b>(m1.c, cM);
   ...
<b>end</b> FluidSystem;
</pre>
</blockquote>

<p>
With these prerequisites, the semantics of the expression
</p>

<blockquote>
<pre><b>inStream</b>(m<sub>i</sub>.c.h_outflow)
</pre>
</blockquote>

<p>
is given implicitly by defining an additional variable <b>h_mix_in</b><sub>i</sub>,
and by adding to the model the conservation equations for mass and energy corresponding
to the infinitesimally small volume spanning the connection set. The connect equation
for the flow variables has already been added to the system according to the connection
semantics of flow variables:
</p>

<blockquote>
<pre>// Standard connection equation for flow variables
0 = <b>sum</b>(m<sub>j</sub>.c.m_flow <b>for</b> j <b>in</b> 1:N) + <b>sum</b>(-c<sub>k</sub>.m_flow <b>for</b> k in 1:M);
</pre></blockquote>

<p>
Whenever the inStream() operator is applied to a stream variable of an
inside connector, the balance equation of the transported property must
be added  under the assumption of flow going into the connector
</p>

<blockquote>
<pre>// Implicit definition of the inStream() operator applied to inside connector i
0 = <b>sum</b>(m<sub>j</sub>.c.m_flow*(<b>if</b> m<sub>j</sub>.c.m_flow > 0 <b>or</b> j==i <b>then</b> h_mix_in<sub>i</sub> <b>else</b> m<sub>j</sub>.c.h_outflow) <b>for</b> j <b>in</b> 1:N) +
    <b>sum</b>(-c<sub>k</sub>.m_flow* (<b>if</b> c<sub>k</sub>.m_flow > 0 <b>then</b> h_mix_in<sub>i</sub> <b>else</b> inStream(c<sub>k</sub>.h_outflow) <b>for</b> k <b>in</b> 1:M);
<b>inStream</b>(m<sub>i</sub>.c.h_outflow) = h_mix_in<sub>i</sub>;
</pre>
</blockquote>

<p>
Note that the result of the inStream(m<sub>i</sub>.c.h_outflow) operator is different for each port i,
because the assumption of flow entering the port is different for each of them.
Additional equations need to be generated for the stream variables of outside connectors.
</p>

<blockquote>
<pre>// Additional connection equations for outside connectors
<b>for</b> q in 1:M <b>loop</b>
  0 = <b>sum</b>(m<sub>j</sub>.c.m_flow*(<b>if</b> m<sub>j</sub>.c.m_flow > 0 <b>then</b> h_mix_out<sub>q</sub> <b>else</b> m<sub>j</sub>.c.h_outflow) <b>for</b> j <b>in</b> 1:N) +
      <b>sum</b>(-c<sub>k</sub>.m_flow* (<b>if</b> c<sub>k</sub>.m_flow > 0 <b>or</b> k==q <b>then</b> h_mix_out<sub>q</sub> <b>else</b> <b>inStream</b>(c<sub>k</sub>.h_outflow)
          <b>for</b> k <b>in</b> 1:M);
  c<sub>q</sub>.h_outflow = h_mix_out<sub>q</sub>;
<b>end for</b>;
</pre></blockquote>

<p>
Neglecting zero flow conditions, the above implicit equations can be
analytically solved for the inStream(..) operators.
The details are given in Section 15.2 of the
<a href="https://www.modelica.org/documents/ModelicaSpec32Revision1.pdf">Modelica Language Specification version 3.2 Revision 1</a>.
The stream connection equations have singularities and/or multiple solutions if one or more
of the flow variables become zero. When all the flows are zero, a singularity is always
present, so it is necessary to approximate the solution in an open neighborhood
of that point. [<i>For example assume that m<sub>j</sub>.c.m_flow = c<sub>k</sub>.m_flow = 0,
then all equations above are identically fulfilled and inStream(..) can have any value</i>].
It is required that the inStream() operator is appropriately approximated in that case
and the approximation must fulfill the following requirements:
</p>

<ol>
<li> inStream(m<sub>i</sub>.c.h_outflow) and inStream(c<sub>k</sub>.h_outflow)
     must be <b>unique</b> with respect to all values of the flow and stream
     variables in the connection set, and must have a continuous dependency on them.<br>&nbsp;</li>
<li> Every solution of the implicit equation system above must fulfill the equation
     system identically [<i>upto the usual numerical accuracy</i>],
     provided the absolute value of every flow variable in the connection set is
     greater than a small value (|m<sub>1</sub>.c.m_flow| &gt; eps and |m<sub>2</sub>.c.m_flow| &gt; eps
     and ... and |c<sub>M</sub>.m_flow| &gt; eps).</li>
</ol>

<p>
In Section 15.2 a recommended implementation of the solution of the implicit equation system is
given, that fulfills the above requirements.
</p>


<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'Integer()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'Integer()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'Integer()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'Integer()'</h2>

<p>
Returns ordinal number of enumeration
</p>
<h4>Syntax</h4>
<blockquote><pre><b>Integer</b>(&lt;expression of enumeration type&gt;)</pre></blockquote>
<h4>Description</h4>
<p>
Returns the ordinal number of the enumeration value E.enumvalue, to which the expression
is evaluated, where Integer(E.e1) =1, Integer(E.en) =size(E), for an enumeration
type E=enumeration(e1, ...,  en).
</p>

<h4>Examples</h4>
<blockquote><pre>
<b>type</b> Size = <b>enumeration</b>(small, medium, large, xlarge);
Size tshirt = Size.large;
Integer tshirtValue = <b>Integer</b>(tshirt);  // = 3
</pre></blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'integer()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'integer()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'integer()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'integer()'</h2>

<p>
Round Real number towards minus infinity
</p>
<h4>Syntax</h4>
<blockquote><pre><b>integer</b>(x)</pre></blockquote>
<h4>Description</h4>
<p>Returns the largest integer not greater than <code>x</code>.
The argument shall have type Real. The result has type Integer.</p>
<p><i>[Note, outside of a when clause state events are triggered
when the return value changes discontinuously.]</i></p>
<h4>Examples</h4>
<pre><b>integer</b>({-3.14, 3.14})
 = {-4, 3}</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'inverse()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'inverse()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'inverse()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'inverse()'</h2>

<p>Every function with one output argument may have one or more &quot;<code>inverse</code>&quot; annotations to define inverses of this function. </p>
<p><b><font style="color: #008000; ">Syntax</font></b> </p>
<blockquote>
<pre><b>function</b> f1
  <b>input</b> A1 u1;
  ...
  <b>input</b> T1 uk;
  ...
  <b>input</b> Am um = am;
  ...
  <b>input</b> An un;
  <b>output</b> T2 y;
  <b>annotation</b>(<b>inverse</b>(uk = f2(..., y, ....), ui = f3(..., y, ...), ...));
<b>algorithm</b>
  ...
<b>end</b> f1;</pre></blockquote>
<h4>Description</h4>
<p>The meaning is that function &quot;<code>f2</code>&quot; is one inverse to function &quot;<code>f1</code>&quot; where the previous output &quot;<code>y</code>&quot; is now an input and the previous input &quot;<code>uk</code>&quot; is now an output. More than one inverse can be defined within the same inverse annotation. Several inverses are separated by commas. <em>(The inverse requires that for all valid values of the input arguments of <code>f2(...,y, ...)</code> and <code>uk</code> being calculated as <code>uk := f2(..., y, ...)</code> implies the equality <code>y = f1(..., uk, ...,) </code>up to a certain precision.)</em></p>
<p>Function &quot;<code>f1</code>&quot; can have any number and types of arguments with and without default value. The restriction is that the number of unknown variables in the output argument of both &quot;<code>f1</code>&quot; and &quot;<code>f2</code>&quot; must be the same and that &quot;<code>f2</code>&quot; must have exactly the same arguments as &quot;<code>f1</code>&quot; (with the same defaults, if an argument um has a default), but the order of the arguments may be permuted.</p>
<h4><font style="color: #008000; ">Examples</font></h4>
<pre><b>function</b> h_pTX
  <b>input</b> Real p    &quot;pressure&quot;;
  <b>input</b> Real T    &quot;temperature&quot;;
  <b>input</b> Real X[:] &quot;mass fractions&quot;;
  <b>output</b> Real h   &quot;specific enthalpy&quot;;
  <b>annotation</b>(<b>inverse</b>(T = T_phX(p,h,X)));
<b>algorithm</b>
  ...
<b>end</b> h_pTX;

<b>function</b> T_phX
  <b>input</b> Real  p    &quot;pressure&quot;;
  <b>input</b> Real  h    &quot;specific enthalpy&quot;;
  <b>input</b> Real  X[:] &quot;mass fractions&quot;;
  <b>output</b> Real T    &quot;temperature&quot;;
<b>algorithm</b>
  ...
<b>end</b> T_phX;</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'linspace()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'linspace()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'linspace()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'linspace()'</h2>

<p>
Return Real vector with equally spaced elements
</p>
<h4>Syntax</h4>
<blockquote><pre><b>linspace</b>(x1, x2, n)</pre></blockquote>
<h4>Description</h4>
<p>
Returns a Real vector with n equally spaced elements,
such that
</p>
<blockquote><pre>
v[i] = x1 + (x2-x1)*(i-1)/(n-1) for 1 &le; i &le; n.
</pre></blockquote>
<p>
It is required that n &ge; 2. The arguments x1 and x2 shall
be Real or Integer scalar expressions.
</p>
<h4>Examples</h4>
<blockquote><pre>
Real v[:] = linspace(1,7,4);  // = {1, 3, 5, 7}
</pre></blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'log()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'log()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'log()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'log()'</h2>

<p>
Natural (base e) logarithm
</p>
<h4>Syntax</h4>
<blockquote><pre><b>log</b>(u)</pre></blockquote>
<h4>Description</h4>
<p>Returns the base e logarithm of u, with u &gt; 0.
Argument u needs to be an Integer or Real expression.</p>

<p>
The natural logarithm can also be accessed as Modelica.Math.log.
</p>

<img src="../Resources/Images/log.png" alt="log">

<h4>Examples</h4>
<pre><b>log</b>(1)
 = 0</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'log10()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'log10()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'log10()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'log10()'</h2>

<p>
Base 10 logarithm
</p>
<h4>Syntax</h4>
<blockquote><pre><b>log10</b>(u)</pre></blockquote>
<h4>Description</h4>
<p>Returns the base 10 logarithm of u, with u &gt; 0.
Argument u needs to be an Integer or Real expression.</p>

<p>
The base 10 logarithm can also be accessed as Modelica.Math.log10.
</p>

<img src="../Resources/Images/log10.png" alt="log10">

<h4>Examples</h4>
<pre><b>log10</b>(1)
 = 0</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'matrix()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'matrix()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'matrix()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'matrix()'</h2>

<p>
Returns the first two dimensions of an array as matrix
</p>
<h4>Syntax</h4>
<blockquote><pre><b>matrix</b>(A)</pre></blockquote>
<h4>Description</h4>
<p>
Returns <b>promote</b>(A,2), if A is a scalar or vector and
otherwise returns the elements of the first two dimensions
as a matrix. <b>size</b>(A,i) = 1 is required for
2 &lt; i &le; <b>ndims</b>(A).
</p>
<p>
Function <b>promote</b>(A,n) fills dimensions of size 1
from the right to array A upto dimension n, where
"n &gt; <b>ndims</b>(A)" is required. Let
C = <b>promote</b>(A,n), with nA = <b>ndims</b>(A),
then
</p>
<blockquote><pre>
<b>ndims</b>(C) = n,
<b>size</b>(C,j) = <b>size</b>(A,j) for 1 &le; j &le; nA,
<b>size</b>(C,j) = 1 for nA+1 &le; j &le; n,
C[i_1, ..., i_nA, 1, ..., 1] = A[i_1, ..., i_nA].
</pre></blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'max()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'max()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'max()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'max()'</h2>

<p>
Returns the largest element
</p>
<h4>Syntax</h4>
<blockquote><pre>
<b>max</b>(A)
<b>max</b>(x,y)
<b>max</b>(e(i, ..., j) <b>for</b> i <b>in</b> u, ..., j <b>in</b> v)
</pre></blockquote>
<h4>Description</h4>
<p>
The first form returns the largest element of array expression A.
</p>
<p>
The second form returns the largest element of the scalars x and y.
</p>
<p>
The third form is a reduction expression and
returns the largest value of the
scalar expression e(i, ..., j) evaluated for all
combinations of i in u, ..., j in v
</p>
<h4>Examples</h4>
<blockquote><pre>
<b>max</b>(i^2 <b>for</b> i <b>in</b> {3,7,6})  // = 49
</pre></blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'min()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'min()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'min()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'min()'</h2>

<p>
Returns the smallest element
</p>
<h4>Syntax</h4>
<blockquote><pre>
<b>min</b>(A)
<b>min</b>(x,y)
<b>min</b>(e(i, ..., j) <b>for</b> i <b>in</b> u, ..., j <b>in</b> v)
</pre></blockquote>
<h4>Description</h4>
<p>
The first form returns the smallest element of array expression A.
</p>
<p>
The second form returns the smallest element of the scalars x and y.
</p>
<p>
The third form is a reduction expression and
returns the smallest value of the
scalar expression e(i, ..., j) evaluated for all
combinations of i in u, ..., j in v
</p>
<h4>Examples</h4>
<blockquote><pre>
<b>min</b>(i^2 <b>for</b> i <b>in</b> {3,7,6})  // = 9
</pre></blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'mod()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'mod()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'mod()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'mod()'</h2>

<p>
Integer modulus of a division of two Real numbers
</p>
<h4>Syntax</h4>
<blockquote><pre><b>mod</b>(x, y)</pre></blockquote>
<h4>Description</h4>
<P>Returns the integer modulus of <CODE>x/y</CODE>, i.e., mod(x, y) = x - floor(x/y)*y.
Result and arguments shall have type Real or Integer. If either of the
arguments is Real the result is Real otherwise Integer. <I>[Note, outside of
a when clause state events are triggered when the return value changes
discontinuously.]</I></P>
<h4>Examples</h4>
<pre><b>mod</b>(3,1.4)
 = 0.2
<b>mod</b>(-3,1.4)
 = 1.2
<b>mod</b>(3,-1.4)
 = -1.2</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'ndims()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'ndims()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'ndims()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'ndims()'</h2>

<p>
Return number of array dimensions
</p>
<h4>Syntax</h4>
<blockquote><pre><b>ndims</b>(A)</pre></blockquote>
<h4>Description</h4>
<p>
Returns the number of dimensions k of array expression
A, with k >= 0.
</p>
<h4>Examples</h4>
<blockquote><pre>
Real A[8,4,5];
Integer n = ndims(A);  // = 3
</pre></blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'noEvent()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'noEvent()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'noEvent()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'noEvent()'</h2>

<p>
Turn off event triggering
</p>
<h4>Syntax</h4>
<blockquote><pre><b>noEvent</b>(expr)</pre></blockquote>
<h4>Description</h4>
<p>Real elementary relations within expr are taken literally, i.e., no state or time event is triggered.</p>
<h4>smooth vs. noEvent</h4>
<p>The noEvent operator implies that real elementary expressions are taken
literally instead of generating crossing functions. The smooth operator
should be used instead of noEvent, in order to avoid events for efficiency
reasons. A tool is free to not generate events for expressions inside smooth.
However, smooth does not guarantee that no events will be generated, and thus
it can be necessary to use noEvent inside smooth. <I>[Note that smooth does
not guarantee a smooth output if any of the occurring variables change
discontinuously.]</i></p>
<p><i>[Example:</i></p>
<PRE>  Real x, y, z;
<B>equation</B>
  x = <B>if</B> time&lt;1 <B>then</B> 2 <B>else</B> time-2;
  z = smooth(0, <B>if</B> time&lt;0 <B>then</B> 0 <B>else</B> time);
  y = smooth(1, noEvent(<B>if</B> x&lt;0 <B>then</B> 0 <B>else</B> sqrt(x)*x));
  // noEvent is necessary.</PRE>
<p><i>]</i></p>
<h4>Examples</h4>
<pre>der(h)=<B>if noEvent</B>(h&gt;0) <B>then</B> -c*sqrt(h) <B>else</B> 0;</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'ones()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'ones()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'ones()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'ones()'</h2>

<p>
Returns an array with "1" elements
</p>
<h4>Syntax</h4>
<blockquote><pre><b>ones</b>(n1, n2, n3, ...)</pre></blockquote>
<h4>Description</h4>
<p>
Return the n1 x n2 x n3 x ... Integer array with all
elements equal to one (ni >=0 ).
</p>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'outerProduct()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'outerProduct()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'outerProduct()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'outerProduct()'</h2>

<p>
Returns the outer product of two vectors
</p>
<h4>Syntax</h4>
<blockquote><pre><b>outerProduct</b>(v1,v2)</pre></blockquote>
<h4>Description</h4>
<p>
Returns the outer product of vectors v1 and v2 <br>
(= matrix(v)*transpose( matrix(v) ) ).
</p>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'pre()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'pre()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'pre()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'pre()'</h2>

<p>
Refer to left limit
</p>
<h4>Syntax</h4>
<blockquote><pre><b>pre</b>(y)</pre></blockquote>
<h4>Description</h4>
<P>Returns the &quot;left limit&quot; y(t<SUP>pre</SUP>)
of variable y(t) at a time instant t. At an event instant,
y(t<SUP>pre</SUP>) is the value of y after the last event
iteration at time instant t. The
<B>pre</B> operator can be applied if the following three
conditions are fulfilled simultaneously:</p>
<ul>
  <li>variable y is a subtype of a simple type</li>
  <li>y is a discrete-time expression</li>
  <li>the operator is <B>not</B> applied in a <B>function</B> class</li>
</ul>
<p>The first value of <B>pre</B>(y) is
determined in the initialization phase.</P>
<P>A new event is triggered if at least for one variable v
&quot;<B>pre</B>(v) &lt;&gt; v&quot; after the active model
equations are evaluated at an event instant. In this case
the model is at once reevaluated. This evaluation sequence
is called &quot;<I>event iteration</I>&quot;. The integration
is restarted, if for all v used in <B>pre</B>-operators the
following condition holds: &quot;<B>pre</B>(v) == v&quot;.</P>
<p><I>[If v and <B>pre</B>(v) are only used in when clauses,
the translator might mask event iteration for variable v since
v cannot change during event iteration. It is a &quot;quality
of implementation&quot; to find the minimal loops for event
iteration, i.e., not all parts of the model need to be
reevaluated.</i></p>
<p><i>The language allows mixed algebraic systems of equations
where the unknown variables are of type Real, Integer, Boolean,
or an enumeration. These systems of equations can be solved by
a global fix point iteration scheme, similarly to the event
iteration, by fixing the Boolean,  Integer, and/or enumeration
unknowns during one iteration. Again, it is a quality of
implementation to solve these systems more efficiently, e.g.,
by applying the fix point iteration scheme to a subset of the
model equations.]</I></p>
<h4>Examples</h4>
<pre><b>model</b> Hysteresis
  Real u;
  Boolean y;
<b>equation</b>
  u = Modelica.Math.sin(<b>time</b>);
  y = u &gt; 0.5 or <b>pre</b>(y) and u &gt;= -0.5;
<b>end</b> Hysteresis;</pre>

<img src="../Resources/Images/pre.png" width="400" height="280" alt="Simulation result">

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'product()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'product()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'product()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'product()'</h2>

<p>
Returns the scalar product
</p>
<h4>Syntax</h4>
<blockquote><pre>
<b>product</b>(A)
<b>product</b>(e(i, ..., j) <b>for</b> i <b>in</b> u, ..., j <b>in</b> v)
</pre></blockquote>
<h4>Description</h4>
<p>
The first form returns the scalar product of all the elements of
array expression A:<br>
A[1,...,1]*A[2,...,1]*....*A[end,...,1]*A[end,...,end]
</p>
<p>
The second form is a reduction expression and
returns the product of the expression e(i, ..., j) evaluated for all combinations of i in u, ..., j in v:
</p>
<blockquote><pre>
e(u[1],...,v[1]) * e(u[2],...,v[1]) * ... *
e(u[end],...,v[1]) * ... * e(u[end],...,v[end])
</pre></blockquote>
<p>
The type of <b>product</b>(e(i, ..., j) <b>for</b> i <b>in</b>
u, ..., j <b>in</b> v) is the same as the type of e(i,...j).
</p>
<h4>Examples</h4>
<blockquote><pre>
{<b>product</b>(j <b>for</b> j <b>in</b> 1:i) <b>for</b> i <b>in</b> 0:4} // = {1,1,2,6,24}
</pre></blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'reinit()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'reinit()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'reinit()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'reinit()'</h2>

<p>
Reinitialize state variable
</p>

<h4>Syntax</h4>
<blockquote><pre><b>reinit</b>(x, expr)</pre></blockquote>
<h4>Description</h4>
<p>
The operator reinitializes <code>x</code> with expr at an event instant. <code>x</code> is a Real variable
(or an array of Real variables) that must be selected as a state (resp., states), that is
reinit on <code>x</code> implies <code>stateSelect = StateSelect.always</code> on <code>x</code>.
<code>expr</code> needs to be type-compatible with <code>x</code>. The reinit operator can for the same variable
(resp. array of variables) only be applied (either as an individual variable or as part
of an array of variables) in one equation (having reinit of the same variable in when and
else-when of the same variable is allowed).
The reinit operator can only be used in the body of a when-equation. It cannot be used
in an algorithm section.
</p>

<p>
The reinit operator does not break the single assignment rule, because reinit(x,expr)
in equations evaluates expr to a value (value), then at the end of the current event iteration step
it assigns this value to x (this copying from values to reinitialized state(s) is done after
all other evaluations of the model and before copying x to pre(x)).
</p>

<p>
<i>
[If a higher index system is present, that is constraints between state variables,
some state variables need to be redefined to non-state variables. During simulation,
non-state variables should be chosen in such a way that variables with an applied reinit
operator are selected as states at least when the corresponding when-clauses become active.
If this is not possible, an error occurs, since otherwise the reinit operator would be applied
on a non-state variable.]
</i>
</p>

<h4>Examples</h4>
<blockquote><pre>
// Bouncing ball
   <b>parameter</b> Real e=0.5 "Coefficient of restitution"
   Real h, v;
   Boolean flying;
<b>equation</b>
   <b>der</b>(h) = v;
   <b>der</b>(v) = <b>if</b> flying <b>then</b> -g <b>else</b> 0;
   flying = <b>not</b> (h&lt;=0 <b>and</b> v&lt;=0);

   <b>when</b> h &lt; 0 <b>then</b>
     <b>reinit</b>(v, -e*<b>pre</b>(v));
   <b>end when</b>;
</pre></blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'rem()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'rem()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'rem()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'rem()'</h2>

<p>
Integer remainder of the division of two Real numbers
</p>
<h4>Syntax</h4>
<blockquote><pre><b>rem</b>(x, y)</pre></blockquote>
<h4>Description</h4>
<P>Returns the integer remainder of <CODE>x/y</CODE>,
such that <CODE>div(x,y) * y + rem(x, y) = x</CODE>.
Result and arguments shall have type Real or
Integer. If either of the arguments is Real the
result is Real otherwise Integer. <I>[Note, outside
of a when clause state events are triggered when
the return value changes discontinuously.]</I></P>
<h4>Examples</h4>
<pre><b>rem</b>(3,1.4)
 = 0.2
<b>rem</b>(-3,1.4)
 = -0.2
<b>rem</b>(3,-1.4)
 = 0.2</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'rooted()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'rooted()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'rooted()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'rooted()'</h2>

<p>
<strong>Deprecated</strong> operator, see <a href="ModelicaReference_Operators.html#ModelicaReference.Operators.'Connections.rooted()'"
>Connections.rooted()</a> instead.
</p>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'sample()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'sample()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'sample()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'sample()'</h2>

<p>
Trigger time events
</p>
<h4>Syntax</h4>
<blockquote><pre><b>sample</b>(start, interval)</pre></blockquote>
<h4>Description</h4>
<P>Returns true and triggers time events at time instants
<CODE>&quot;start + i*interval&quot; (i=0, 1, ...)</CODE>.
During continuous integration the operator returns always
false. The starting time &quot;start&quot; and the sample
interval &quot;interval&quot; need to be parameter
expressions and need to be a subtype of Real or Integer.
</P>
<h4>Examples</h4>
<pre><b>model</b> Sampling
  Integer i;
<b>equation</b>
  <b>when</b> <b>sample</b>(1, 0.1) <b>then</b>
    i = <b>pre</b>(i) + 1;
  <b>end when</b>;
<b>end</b> Sampling;</pre>

<img src="../Resources/Images/sample.png" width="400" height="280" alt="Simulation result">

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'scalar()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'scalar()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'scalar()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'scalar()'</h2>

<p>
Returns a one-element array as scalar
</p>
<h4>Syntax</h4>
<blockquote><pre><b>scalar</b>(A)</pre></blockquote>
<h4>Description</h4>
<p>
Returns the single element of array A.
<b>size</b>(A,i) = 1 is required for 1 &le; i &le; <b>ndims</b>(A).
</p>
<h4>Examples</h4>
<blockquote><pre>
Real A[1,1,1] = {{{3}}};
Real e = scalar(A);  // = 3
</pre></blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'semiLinear()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'semiLinear()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'semiLinear()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'semiLinear()'</h2>

<p>
Returns "if x >= 0 then positiveSlope*x else negativeSlope*x" and handle x=0 in a meaningful way
</p>
<h4>Syntax</h4>
<blockquote><pre><b>semiLinear</b>(x, positiveSlope, negativeSlope)</pre></blockquote>
<h4>Description</h4>
<p>
Returns "if x >= 0 then positiveSlope*x else negativeSlope*x".
In some situations, equations with the semiLinear function
become underdetermined if the first argument (x) becomes
zero, i.e., there are an infinite number of solutions.
It is recommended that the following rules are used to
transform the equations during the translation phase in
order to select one meaningful solution in such cases:
</p>
<p>
<b>Rule 1</b>: The equations
</p>
<blockquote>
<pre>
y = <b>semiLinear</b>(x, sa, s1);
y = <b>semiLinear</b>(x, s1, s2);
y = <b>semiLinear</b>(x, s2, s3);
   ...
y = <b>semiLinear</b>(x, sN, sb);
</pre>
</blockquote>
<p>
may be replaced by
</p>
<blockquote>
<pre>
s1 = <b>if</b> x >= 0 <b>then</b> sa <b>else</b> sb
s2 = s1;
s3 = s2;
   ...
sN = sN-1;
y = <b>semiLinear</b>(x, sa, sb);
</pre>
</blockquote>
<p>
<b>Rule 2</b>: The equations
</p>
<blockquote>
<pre>
x = 0;
y = 0;
y = <b>semiLinear</b>(x, sa, sb);
</pre>
</blockquote>
<p>
may be replaced by
</p>
<blockquote>
<pre>
x = 0
y = 0;
sa = sb;
</pre>
</blockquote>
<p>
<i> [For symbolic transformations, the following property is
useful (this follows from the definition):</i>
</p>
<blockquote>
<pre>
<b>semiLinear</b>(m_flow, port_h, h);
</pre>
</blockquote>
<p>
is identical to
</p>
<blockquote><pre>
-<b>semiLinear</b>(-m_flow, h, port_h);
</pre></blockquote>
<p>
<i> The semiLinear function is designed to handle reversing
flow in fluid systems, such as</i>
</p>
<blockquote><pre>
H_flow = <b>semiLinear</b>(m_flow, port.h, h);
</pre></blockquote>
<p>
<i> i.e., the enthalpy flow rate H _flow is computed from the mass flow
rate m_flow and the upstream specific enthalpy depending on the
flow direction.]</i>
</p>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'sign()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'sign()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'sign()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'sign()'</h2>

<p>
Sign function of a Real or Integer number
</p>
<h4>Syntax</h4>
<blockquote><pre><b>sign</b>(v)</pre></blockquote>
<h4>Description</h4>
<p>Is expanded into &quot;noEvent(<b>if</b> v &gt; 0 <b>then</b> 1 <b>else
if</b> v &lt; 0 <b>then</b> -1 <b>else</b> 0)&quot;. Argument v
needs to be an Integer or Real expression. <i>[Note, outside of a
when clause state events are triggered.]</i></p>
<h4>Examples</h4>
<pre><b>sign</b>({-3, 0, 3})
 = {-1, 0, 1}</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'sin()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'sin()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'sin()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'sin()'</h2>

<p>
Trigonometric sine function
</p>
<h4>Syntax</h4>
<blockquote><pre><b>sin</b>(u)</pre></blockquote>
<h4>Description</h4>
<p>Returns the sine of u, with -&infin; &lt; u &lt; &infin;.
Argument u needs to be an Integer or Real expression.</p>

<p>
The sine function can also be accessed as Modelica.Math.sin.
</p>

<img src="../Resources/Images/sin.png" alt="sin">

<h4>Examples</h4>
<pre><b>sin</b>(3.14159265358979)
 = 0.0</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'sinh()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'sinh()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'sinh()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'sinh()'</h2>

<p>
Hyperbolic sine function
</p>
<h4>Syntax</h4>
<blockquote><pre><b>sinh</b>(u)</pre></blockquote>
<h4>Description</h4>
<p>Returns the sinh of u, with -&infin; &lt; u &lt; &infin;.
Argument u needs to be an Integer or Real expression.</p>

<p>
The sinh function can also be accessed as Modelica.Math.sinh.
</p>

<img src="../Resources/Images/sinh.png" alt="sinh">

<h4>Examples</h4>
<pre><b>sinh</b>(1)
  = 1.1752011936438</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'size()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'size()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'size()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'size()'</h2>

<p>
Returns dimensions of an array
</p>
<h4>Syntax</h4>
<blockquote><pre>
   <b>size</b>(A,i)
   <b>size</b>(A)
</pre></blockquote>
<h4>Description</h4>
<p>
The first form returns the size of dimension i of array expression A
where i shall be &gt; 0 and &le; <b>ndims</b>(A).
</p>
<p>
The second form returns a vector of length <b>ndims</b>(A)
containing the dimension sizes of A.
</p>
<h4>Examples</h4>
<blockquote><pre>
Real A[8,4,5];
Integer n3   = size(A,3);  // = 5
Integer n[:] = size(A);    // = {8,4,5}
</pre></blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'skew()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'skew()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'skew()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'skew()'</h2>

<p>
Returns the skew matrix that is associated with a vector
</p>
<h4>Syntax</h4>
<blockquote><pre><b>skew</b>(x)</pre></blockquote>
<h4>Description</h4>
<p>
Returns the 3 x 3 skew symmetric matrix associated with a
3-vector, i.e.,
</p>
<blockquote><pre>
<b>cross</b>(x,y) = <b>skew</b>(x)*y;
<b>skew</b>(x) = [ 0   , -x[3],  x[2];
            x[3],  0   , -x[1];
           -x[2],  x[1],  0   ];
</pre></blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'smooth()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'smooth()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'smooth()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'smooth()'</h2>

<p>
Indicate smoothness of expression
</p>
<h4>Syntax</h4>
<blockquote><pre><b>smooth</b>(p, expr)</pre></blockquote>
<h4>Description</h4>
<P>If p&gt;=0 <B>smooth</B>(p, expr) returns expr and states
that expr is p times continuously differentiable, i.e.: expr
is continuous in all real variables appearing in the expression
and all partial derivatives with respect to all appearing real
variables <B>exist</B> and are continuous up to order p.</p>
<p>The only allowed types for expr in smooth are: real expressions,
arrays of allowed expressions, and records containing only
components of allowed expressions.</P>
<h4>smooth vs. noEvent</h4>
<p>The noEvent operator implies that real elementary expressions are taken
literally instead of generating crossing functions. The smooth operator
should be used instead of noEvent, in order to avoid events for efficiency
reasons. A tool is free to not generate events for expressions inside smooth.
However, smooth does not guarantee that no events will be generated, and thus
it can be necessary to use noEvent inside smooth. <I>[Note that smooth does
not guarantee a smooth output if any of the occurring variables change
discontinuously.]</I></p>
<h4>Examples</h4>
<PRE>  Real x, y, z;
<B>equation</B>
  x = <B>if</B> time&lt;1 <B>then</B> 2 <B>else</B> time-2;
  z = smooth(0, <B>if</B> time&lt;0 <B>then</B> 0 <B>else</B> time);
  y = smooth(1, noEvent(<B>if</B> x&lt;0 <B>then</B> 0 <B>else</B> sqrt(x)*x));
  // noEvent is necessary.</PRE>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'sqrt()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'sqrt()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'sqrt()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'sqrt()'</h2>

<p>
Square root
</p>
<h4>Syntax</h4>
<blockquote><pre><b>sqrt</b>(v)</pre></blockquote>
<h4>Description</h4>
<p>Returns the square root of v if v&gt;=0, otherwise an error occurs.
Argument v needs to be an Integer or Real expression.</p>
<h4>Examples</h4>
<pre><b>sqrt</b>(9)
 = 3.0</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'String()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'String()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'String()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'String()'</h2>

<p>
Convert a scalar Real, Integer or Boolean expression to a String representation
</p>
<h4>Syntax</h4>
<blockquote>
<pre>
<b>String</b>(b_expr, minimumLength=0, leftJustified=true)
<b>String</b>(i_expr, minimumLength=0, leftJustified=true)
<b>String</b>(r_expr, significantDigits=6, minimumLength=0, leftJustified=true)
<b>String</b>(r_expr, format)
<b>String</b>(e_expr, minimumLength=0, leftJustified=true)
</pre>
</blockquote>
<h4>Description</h4>
<p>
The arguments have the following meaning
(the default values of the optional arguments are shown in the left column):
</p>
<table border=1 cellspacing=0 cellpadding=2>
<tr>
  <td> Boolean b_expr</td>
  <td> Boolean expression</td></tr>
<tr>
  <td> Integer i_expr</td>
  <td> Integer expression</td></tr>
<tr>
  <td> Real r_expr</td>
  <td> Real expression</td></tr>
<tr>
  <td> type e_expr = enumeration(..)</td>
  <td> Enumeration expression</td></tr>
<tr>
  <td> Integer minimumLength = 0 </td>
  <td> Minimum length of the resulting string. If necessary, <br>
       the blank character is used to fill up unused space.</td></tr>
<tr>
  <td> Boolean leftJustified = <b>true</b> </td>
  <td> if <b>true</b>, the converted result is left justified;<br>
       if <b>false</b>, it is right justified in the string.</td></tr>
<tr>
  <td> Integer significantDigits = 6 </td>
  <td> defines the number of significant digits in the result string<br>
       (e.g., "12.3456", "0.0123456", "12345600", "1.23456E-10")</td></tr>
<tr>
  <td> String format </td>
  <td> defines the string formatting according to ANSI-C without "%" and "*" character<br>
       (e.g., ".6g", "14.5e", "+6f"). In particular:<br>
&nbsp;&nbsp;&nbsp;&nbsp;
format = "[&lt;flags&gt;] [&lt;width&gt;] [.&lt;precision&gt;] &lt;conversion&gt;"<br>
with
<table>
<tr>
  <td>&lt;flags&gt;</td>
  <td> zero, one or more of<br>
       "-": left adjustment of the converted number<br>
       "+": number will always be printed with a sign<br>
       "0": padding to the field width with leading zeros</td></tr>
<tr>
  <td>&lt;width&gt;</td>
  <td> Minimum field width. The converted number will be printed in a field at<br>
       least this wide and wider if necessary. If the converted number has <br>
       fewer characters it will be padded on the left (or the right depending<br>
       on &lt;flags&gt;) with blanks or 0 (depending on &lt;flags&gt;).</td></tr>
<tr>
  <td>&lt;precision&gt;</td>
  <td> The number of digits to be printed after the decimal point for <br>
       e, E, or f conversions, or the number of significant digits for <br>
       g or G conversions.</td></tr>
<tr>
  <td> &lt;conversion&gt;</td>
  <td> = "e": Exponential notation using a  lower case e<br>
       = "E": Exponential notation using an upper case E<br>
       = "f": Fixed point notation<br>
       = "g": Either "e" or "f"<br>
       = "G": Same as "g", but with upper case E</td></tr></table>
</table>
<h4>Examples</h4>
<blockquote>
<pre>
String(2.0)   // = "2.0"
String(true)  // = "true"
String(123, minimumLength=6, leftJustified=false)  // = "   123"
</pre>
</blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'sum()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'sum()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'sum()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'sum()'</h2>

<p>
Returns the scalar sum
</p>
<h4>Syntax</h4>
<blockquote><pre>
<b>sum</b>(A)
<b>sum</b>(e(i, ..., j) <b>for</b> i <b>in</b> u, ..., j <b>in</b> v)
</pre></blockquote>
<h4>Description</h4>
<p>
The first form returns the scalar sum of all the elements of
array expression A:<br>
A[1,...,1]+A[2,...,1]+....+A[end,...,1]+A[end,...,end]
</p>
<p>
The second form is a reduction expression and
returns the sum of the expression e(i, ..., j) evaluated for all combinations of i in u, ..., j in v:
</p>
<blockquote><pre>
e(u[1],...,v[1]) + e(u[2],...,v[1]) + ... +
e(u[end],...,v[1]) + ... + e(u[end],...,v[end])
</pre></blockquote>
<p>
The type of <b>sum</b>(e(i, ..., j) <b>for</b> i <b>in</b>
u, ..., j <b>in</b> v) is the same as the type of e(i,...j).
</p>
<h4>Examples</h4>
<blockquote><pre>
<b>sum</b>(i <b>for</b> i <b>in</b> 1:10)  // Gives  1+2+...+10=55
   // Read it as: compute the sum of i for i in the range 1 to 10.
</pre></blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'symmetric()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'symmetric()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'symmetric()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'symmetric()'</h2>

<p>
Returns a symmetric matrix
</p>
<h4>Syntax</h4>
<blockquote><pre><b>symmetric</b>(A)</pre></blockquote>
<h4>Description</h4>
<p>
Returns a matrix where the diagonal elements and the
elements above the diagonal are identical to the
corresponding elements of matrix A and where the
elements below the diagonal are set equal to the elements
above the diagonal of A, i.e.,
</p>
<blockquote><pre>
B := <b>symmetric</b>(A)
     -> B[i,j] := A[i,j], <b>if</b> i &le; j,
        B[i,j] := A[j,i], <b>if</b> i &gt; j.
</pre></blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'tan()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'tan()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'tan()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'tan()'</h2>

<p>
Trigonometric tangent function
</p>
<h4>Syntax</h4>
<blockquote><pre><b>tan</b>(u)</pre></blockquote>
<h4>Description</h4>
<p>Returns the tangent of u, with -&infin; &lt; u &lt; &infin;
(if u is a multiple of (2n-1)*pi/2, y = tan(u) is +/- infinity).
Argument u needs to be an Integer or Real expression.</p>

<p>
The tangent function can also be accessed as Modelica.Math.tan.
</p>

<img src="../Resources/Images/tan.png" alt="tan">

<h4>Examples</h4>
<pre><b>tan</b>(3.14159265358979)
 = 0.0
</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'tanh()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'tanh()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'tanh()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'tanh()'</h2>

<p>
Hyperbolic tangent function
</p>
<h4>Syntax</h4>
<blockquote><pre><b>tanh</b>(u)</pre></blockquote>
<h4>Description</h4>
<p>Returns the tanh of u, with -&infin; &lt; u &lt; &infin;.
Argument u needs to be an Integer or Real expression.</p>

<p>
The tanh function can also be accessed as Modelica.Math.tanh.
</p>

<img src="../Resources/Images/tanh.png" alt="tanh">

<h4>Examples</h4>
<pre><b>tanh</b>(1)
  = 0.761594155955765</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'terminal()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'terminal()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'terminal()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'terminal()'</h2>

<p>
True after successful analysis
</p>
<h4>Syntax</h4>
<blockquote><pre><b>terminal</b>()</pre></blockquote>
<h4>Description</h4>
<p>Returns <b>true</b> at the end of a successful analysis.</p>
<h4>Examples</h4>
<pre>  Boolean a, b;
<b>equation</b>
  a = <b>change</b>(b) or <b>terminal</b>();</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'terminate()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'terminate()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'terminate()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'terminate()'</h2>

<p>
Successfully terminate current analysis
</p>
<h4>Syntax</h4>
<blockquote><pre><b>terminate</b>(message)</pre></blockquote>
<h4>Description</h4>
<P>The terminate function successfully terminates the analysis
which was carried out. The function has a string argument
indicating the reason for the success. <I>[The intention is to
give more complex stopping criteria than a fixed point in time.]</I></P>
<h4>Examples</h4>
<pre><B>model</B> ThrowingBall
  Real x(start=0);
  Real y(start=1);
<B>equation</B>
  <b>der</b>(x)= ... ;
  <b>der</b>(y)= ... ;
<B>algorithm</B>
  <B>when</B> y &lt; 0 <B>then</B>
    <b>terminate</b>("The ball touches the ground");
  <B>end when;
end</B> ThrowingBall;</pre>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'transpose()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'transpose()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'transpose()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'transpose()'</h2>

<p>
Transpose of a matrix or permutation of the first two dimensions of an array
</p>
<h4>Syntax</h4>
<blockquote><pre><b>transpose</b>(A)</pre></blockquote>
<h4>Description</h4>
<p>
Permutes the first two dimensions of array A.
It is an error, if array A does not have at least
2 dimensions.
</p>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'vector()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'vector()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'vector()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'vector()'</h2>

<p>
Returns an array with one non-singleton dimension as vector
</p>
<h4>Syntax</h4>
<blockquote><pre><b>vector</b>(A)</pre></blockquote>
<h4>Description</h4>
<p>
Returns a 1-vector, if A is a scalar and otherwise returns a vector containing all the elements of the array, provided there is at
most one dimension size > 1.
</p>
<h4>Examples</h4>
<blockquote><pre>
Real A[1,2,1] = {{{3},{4}}};
Real v[2] = vector(A);  // = {3,4}
</pre></blockquote>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<!--[if supportFields]><span style="mso-element:field-begin"></span>
<span style="mso-spacerun:yes"></span>XE 'zeros()'<![endif]-->
<!--[if supportFields]><span style="mso-element:field-end"></span><![endif]-->
<h2><img src="ModelicaReference.AnnotationsI.png" alt="ModelicaReference.Operators.'zeros()'" align="right" style="border: 1px solid" width="80" height="80">
<a name="ModelicaReference.Operators.'zeros()'"></a><a href="ModelicaReference_Operators.html#ModelicaReference.Operators"
>ModelicaReference.Operators</a>.'zeros()'</h2>

<p>
Returns a zero array.
</p>
<h4>Syntax</h4>
<blockquote><pre><b>zeros</b>(n1, n2, n3, ...)</pre></blockquote>
<h4>Description</h4>
<p>
Returns the n1 x n2 x n3 x ... Integer array with all
elements equal to zero (ni >= 0).
</p>

<p>Extends from <a href="ModelicaReference_Icons.html#ModelicaReference.Icons.Information"
>ModelicaReference.Icons.Information</a> (Icon for general information packages).</p>
<h3>Filename</h3>
<pre>ModelicaReference_Operators.html</pre>
<hr>
<address>
<a href="http://www.3ds.com/">Automatically generated</a> Fri Nov  8 12:21:38 2013.
</address>
</body>
</html>
